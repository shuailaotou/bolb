<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>张帅区块链博客</title>
    <description>张帅，江湖人称帅哥，区块链技术全能技术人才。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 04 Jun 2018 21:28:03 +0800</pubDate>
    <lastBuildDate>Mon, 04 Jun 2018 21:28:03 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>自定义加密算法实现--Go语言</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;encoding/base64&quot;
)


func main() {


//1232cdab89 为自定义的秘钥
EncryCode :=Encrypt([]byte(&quot;hello world&quot;),[]byte(&quot;1232cdab89&quot;))
    fmt.Println(base64.StdEncoding.EncodeToString(EncryCode))

	// 解密
	var DeCryptCode = Decrypt(EncryCode,[]byte(&quot;1232cdab89&quot;))
	//打印明文
	fmt.Println(string(DeCryptCode))

	
}
//orig明文，key 密钥
func Encrypt(orig []byte,key []byte)[]byte  {
 //加密方式，对密钥进行加法运算
	sum := getAddIteam(key)

	//给明文补码，默认按8取模
	var pk_code = PKCS8Padding(orig,8)
	
	//补码之后的每一位都加上通过密钥算出的sum值
	for k := 0; k &amp;lt; len(pk_code); k++ {
		pk_code[k] = pk_code[k] + byte(sum)

	}
    return pk_code


}

func Decrypt(orig []byte,key []byte)[]byte  {
	sum := getAddIteam(key)

	//解密
	for k := 0; k &amp;lt; len(orig); k++ {
		orig[k] = orig[k] - byte(sum)
	}

//去补码
	var pk_up_code  = PKCS8UnPadding(orig)
	return pk_up_code

	
}

//补码，按8取模，对8差几补几
func PKCS8Padding(orig []byte,size int)[]byte  {

	length:=len(orig)
	padding :=  size - length%size
	//向byte类型的数组中添加重复的添加padding
	repeats:= bytes.Repeat([]byte{byte(padding)},padding)
	return append(orig,repeats...)

}
//去码

func PKCS8UnPadding(origData []byte)[]byte {

	length:= len(origData)
	updadding:= int(origData[length - 1])
	return origData[:length - updadding]
	
}
 //加密方式，对密钥进行加法运算

func getAddIteam(key []byte) int  {


	var sum  = 0
	//实现将秘钥中的每个字节相加，通过sum实现orig的加密工作
	for i := 0; i &amp;lt; len(key); i++ {

		sum = sum + int(key[i])

	}
	return sum
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;如有错误描述，请评论纠正，谢谢大家！🐳🐳🐳&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 04 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/04/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-Go%E8%AF%AD%E8%A8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/04/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-Go%E8%AF%AD%E8%A8%80/</guid>
        
        <category>加密算法</category>
        
        
      </item>
    
      <item>
        <title>以太坊源码解析 - 下载、编译 go-ethereum ，搭建私有链</title>
        <description>&lt;h2 id=&quot;下载&quot;&gt;下载&lt;/h2&gt;
&lt;p&gt;找到&lt;code class=&quot;highlighter-rouge&quot;&gt;Go&lt;/code&gt;语言环境的&lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;目录下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;github.com&lt;/code&gt;(如果没有创建一个，一般github上的代码下载到这个目录)目录,然后下载以太坊源码&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-30-01.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/ethereum/go-ethereum.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;编译&quot;&gt;编译&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd go-ethereum
$ make geth 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make geth&lt;/code&gt;之后出现如下图表示成功&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-30-04.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;将 &lt;code class=&quot;highlighter-rouge&quot;&gt;geth&lt;/code&gt; 添加到环境变量中&lt;/p&gt;

&lt;p&gt;Mac 中在finder中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;command+shift+g&lt;/code&gt;然后输入&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt;前往，用命令端口打开bashrc目录，&lt;code class=&quot;highlighter-rouge&quot;&gt;vi bashrc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-30-02.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export GETH=&quot;$GOPATH/src/github.com/go-ethereum/build&quot;
export PATH=&quot;$PATH:$GETH/bin&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-30-03.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;保存退出后，
然后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;source bashrc&lt;/code&gt;，使配置生效。&lt;/p&gt;

&lt;p&gt;检查是否安装成功&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --help
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果输出一些帮助提示命令，则说明安装成功。&lt;/p&gt;

&lt;h2 id=&quot;搭建私有链&quot;&gt;搭建私有链&lt;/h2&gt;

&lt;h3 id=&quot;配置初始状态&quot;&gt;配置初始状态&lt;/h3&gt;

&lt;p&gt;要运行以太坊私有链，需要定义自己的创世区块，创世区块信息写在一个 JSON 格式的配置文件中。首先将下面的内容保存到一个 JSON 文件中，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;genesis.json&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir ~/privatechain
$ cd ~/privatechain
$ mkdir data0
$ vi genesis.json 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;genesis.json 的代码&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;config&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;chainId&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;homesteadBlock&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;eip155Block&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;eip158Block&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;alloc&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;coinbase&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;difficulty&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x20000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;extraData&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;gasLimit&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x2fefd8&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;nonce&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000042&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;mixhash&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;parentHash&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;timestamp&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x00&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，chainID 指定了独立的区块链网络 ID。网络 ID 在连接到其他节点的时候会用到，以太坊公网的网络 ID 是 1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络 ID。不同 ID 网络的节点无法相互连接。配置文件还对当前挖矿难度 difficulty、区块 Gas 消耗限制 gasLimit 等参数进行了设置。&lt;/p&gt;

&lt;h3 id=&quot;初始化写入创世区块&quot;&gt;初始化：写入创世区块&lt;/h3&gt;

&lt;p&gt;准备好创世区块配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录用来存放区块链数据，假设新建的数据目录为 ~/privatechain/data0，genesis.json 保存在 ~/privatechain 中，此时目录结构应该是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;privatechain
├── data0
└── genesis.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行初始化命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --datadir data0 init genesis.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的命令的主体是 &lt;code class=&quot;highlighter-rouge&quot;&gt;geth init&lt;/code&gt;，表示初始化区块链，命令可以带有选项和参数，其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;--datadir&lt;/code&gt; 选项后面跟一个目录名，这里为 &lt;code class=&quot;highlighter-rouge&quot;&gt;data0&lt;/code&gt;，表示指定数据存放目录为 &lt;code class=&quot;highlighter-rouge&quot;&gt;data0&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;genesis.json&lt;/code&gt; 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 命令的参数。&lt;/p&gt;

&lt;p&gt;运行上面的命令，会读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;genesis.json&lt;/code&gt; 文件，根据其中的内容，将创世区块写入到区块链中。如果看到以下的输出内容，说明初始化成功了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INFO [01-29|21:21:13] Maximum peer count                       ETH=25 LES=0 total=25
INFO [01-29|21:21:13] Allocated cache and file handles         database=/Users/fujinliang/privatechain/data0/geth/chaindata cache=16 handles=16
INFO [01-29|21:21:13] Writing custom genesis block 
INFO [01-29|21:21:13] Persisted trie from memory database      nodes=0 size=0.00B time=358.89µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [01-29|21:21:13] Successfully wrote genesis state         database=chaindata                                           hash=5e1fc7…d790e0
INFO [01-29|21:21:13] Allocated cache and file handles         database=/Users/fujinliang/privatechain/data0/geth/lightchaindata cache=16 handles=16
INFO [01-29|21:21:13] Writing custom genesis block 
INFO [01-29|21:21:13] Persisted trie from memory database      nodes=0 size=0.00B time=2.633µs  gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [01-29|21:21:13] Successfully wrote genesis state         database=lightchaindata                                           hash=5e1fc7…d790e0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;初始化成功后，会在数据目录 data0 中生成 geth 和 keystore 两个文件夹，此时目录结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;privatechain
├── data0
│   ├── geth
│   │   ├── chaindata
│   │   │   ├── 000001.log
│   │   │   ├── CURRENT
│   │   │   ├── LOCK
│   │   │   ├── LOG
│   │   │   └── MANIFEST-000000
│   │   └── lightchaindata
│   │       ├── 000001.log
│   │       ├── CURRENT
│   │       ├── LOCK
│   │       ├── LOG
│   │       └── MANIFEST-000000
│   └── keystore
└── genesis.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;geth/chaindata&lt;/code&gt; 中存放的是区块数据，&lt;code class=&quot;highlighter-rouge&quot;&gt;keystore&lt;/code&gt; 中存放的是账户数据。&lt;/p&gt;

&lt;h3 id=&quot;启动私有链节点&quot;&gt;启动私有链节点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;geth --datadir data0 --networkid 110 console
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面命令的主体是 &lt;code class=&quot;highlighter-rouge&quot;&gt;geth console&lt;/code&gt;，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，&lt;code class=&quot;highlighter-rouge&quot;&gt;--networkid&lt;/code&gt; 选项后面跟一个数字，这里是110，表示指定这个私有链的网络id为110。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id。&lt;/p&gt;

&lt;p&gt;运行上面的命令后，就启动了区块链节点并进入了该节点的控制台：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.10-unstable-ccc0debb/darwin-amd64/go1.10.2
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是一个交互式的 JavaScript 执行环境，在这里面可以执行 JavaScript 代码，其中 &amp;gt; 是命令提示符。在这个环境里也内置了一些用来操作以太坊的 JavaScript 对象，可以直接使用这些对象。这些对象主要包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;eth：包含一些跟操作区块链相关的方法；&lt;/li&gt;
  &lt;li&gt;net：包含一些查看p2p网络状态的方法；&lt;/li&gt;
  &lt;li&gt;admin：包含一些与管理节点相关的方法；&lt;/li&gt;
  &lt;li&gt;miner：包含启动&amp;amp;停止挖矿的一些方法；&lt;/li&gt;
  &lt;li&gt;personal：主要包含一些管理账户的方法；&lt;/li&gt;
  &lt;li&gt;txpool：包含一些查看交易内存池的方法；&lt;/li&gt;
  &lt;li&gt;web3：包含了以上对象，还包含一些单位换算的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;控制台操作&quot;&gt;控制台操作&lt;/h2&gt;

&lt;p&gt;进入以太坊 Javascript Console 后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。&lt;/p&gt;

&lt;p&gt;常用命令有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;personal.newAccount()：创建账户；&lt;/li&gt;
  &lt;li&gt;personal.unlockAccount()：解锁账户；&lt;/li&gt;
  &lt;li&gt;eth.accounts：枚举系统中的账户；&lt;/li&gt;
  &lt;li&gt;eth.getBalance()：查看账户余额，返回值的单位是 Wei（Wei 是以太坊中最小货币面额单位，类似比特币中的聪，1 ether = 10^18 Wei）；&lt;/li&gt;
  &lt;li&gt;eth.blockNumber：列出区块总数；&lt;/li&gt;
  &lt;li&gt;eth.getTransaction()：获取交易；&lt;/li&gt;
  &lt;li&gt;eth.getBlock()：获取区块；&lt;/li&gt;
  &lt;li&gt;miner.start()：开始挖矿；&lt;/li&gt;
  &lt;li&gt;miner.stop()：停止挖矿；&lt;/li&gt;
  &lt;li&gt;eth.coinbase：挖矿奖励的账户&lt;/li&gt;
  &lt;li&gt;web3.fromWei()：Wei 换算成以太币；&lt;/li&gt;
  &lt;li&gt;web3.toWei()：以太币换算成 Wei；&lt;/li&gt;
  &lt;li&gt;txpool.status：交易池中的状态；&lt;/li&gt;
  &lt;li&gt;admin.addPeer()：连接到其他节点；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;创建账户&quot;&gt;创建账户&lt;/h3&gt;

&lt;p&gt;输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth.accounts&lt;/code&gt; 查询系统中的账户：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.accounts
[]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示为 &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;，表示没有账户，接下来使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;personal.newAccount()&lt;/code&gt; 来创建一个账户：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; personal.newAccount()
Passphrase: 
Repeat passphrase: 
&quot;0xfb9cc019fc650a1699d05b7fb564b83c3a72b64d&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Passphrase&lt;/code&gt; 表示输入密码，&lt;code class=&quot;highlighter-rouge&quot;&gt;Repeat passphrase&lt;/code&gt; 表示输入确认密码&lt;/p&gt;

&lt;p&gt;再次创建一个账户&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; personal.newAccount()
Passphrase: 
Repeat passphrase: 
&quot;0xc6b5702b15a3794374e28f41f36e1e8dbdd564df&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看刚刚创建的用户：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.accounts
[&quot;0xfb9cc019fc650a1699d05b7fb564b83c3a72b64d&quot;, &quot;0xc6b5702b15a3794374e28f41f36e1e8dbdd564df&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;账户默认会保存在数据目录的 &lt;code class=&quot;highlighter-rouge&quot;&gt;data0/keystore&lt;/code&gt; 文件夹中。可以查看其中的文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fb9cc019fc650a1699d05b7fb564b83c3a72b64d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;crypto&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;cipher&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;aes-128-ctr&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;ciphertext&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0efae4f94134172b785f1f635be8e70342bf31e1e0ecad21d672594f09ccf572&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;cipherparams&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;iv&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;37f4f3fa2cf070b70e3eb668fad6f46f&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;kdf&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;scrypt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;kdfparams&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;dklen&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;n&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;262144&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;salt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1cdd1cf97fb882c3d3e734223668b47c888170e795346e11d0f521a71fe3aa2a&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;mac&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;902a29db25a3a35a2568b04b30a8194201f07ab37c96ed1fe9af932fc1d38be0&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ecd5beb2-8261-4207-8eff-2fa34678d064&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;查看账户余额&quot;&gt;查看账户余额&lt;/h3&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth.getBalance()&lt;/code&gt; 可以查看账户余额&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.getBalance(eth.accounts[0])
0
&amp;gt; eth.getBalance(eth.accounts[1])
0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。&lt;/p&gt;

&lt;h3 id=&quot;启动停止挖矿&quot;&gt;启动&amp;amp;停止挖矿&lt;/h3&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;miner.start()&lt;/code&gt; 启动挖矿&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; miner.start(3)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;其中 start 的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的 DAG 文件，这个过程有点慢，等进度达到 100% 后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。&lt;/p&gt;

&lt;p&gt;停止挖矿，在 console 中输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;miner.stop()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;**复制&lt;code class=&quot;highlighter-rouge&quot;&gt;miner.stop()&lt;/code&gt;到命令行，快速的回车，同样等到100%之后，自动停止挖矿。&lt;/p&gt;

&lt;p&gt;挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.coinbase
&quot;0xfb9cc019fc650a1699d05b7fb564b83c3a72b64d&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;miner.setEtherbase()&lt;/code&gt; 将其他账户设置成 &lt;code class=&quot;highlighter-rouge&quot;&gt;coinbase&lt;/code&gt; 即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; miner.setEtherbase(eth.accounts[1])
true
&amp;gt; eth.coinbase
&quot;0xc6b5702b15a3794374e28f41f36e1e8dbdd564df&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重新启动挖矿，查看 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth.accounts[1]&lt;/code&gt; 是否可以获得以太币&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; miner.start(3)

//等待几秒后
&amp;gt; miner.stop()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查询账户余额：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.getBalance(eth.accounts[0])
280000000000000000000
&amp;gt; eth.getBalance(eth.accounts[1])
210000000000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;发现账户0 和 账号1 都有以太币，说明 &lt;code class=&quot;highlighter-rouge&quot;&gt;miner.setEtherbase()&lt;/code&gt; 设置成功。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getBalance()&lt;/code&gt; 返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; web3.fromWei(eth.getBalance(eth.accounts[0]),'ether')
280

&amp;gt; web3.fromWei(eth.getBalance(eth.accounts[1]),'ether')
210
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;发送交易&quot;&gt;发送交易&lt;/h3&gt;

&lt;p&gt;我们从账户0转移10个以太币到账户1,首先要解锁账户 0，才能发起交易：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; personal.unlockAccount(eth.accounts[0])
Unlock account 0xfb9cc019fc650a1699d05b7fb564b83c3a72b64d
Passphrase: 
true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发起交易&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; amount = web3.toWei(10,'ether')
&quot;10000000000000000000&quot;
&amp;gt; eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount})
INFO [05-29|22:37:32] Submitted transaction                    fullhash=0x493e8aa2bcb6b2a362bdbd86b2c454279e14beea43b444aeb45c7f667bf572e2 recipient=0xc6b5702B15a3794374e28f41F36e1E8dBDd564DF
&quot;0x493e8aa2bcb6b2a362bdbd86b2c454279e14beea43b444aeb45c7f667bf572e2&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查询 账户1 的余额：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; web3.fromWei(eth.getBalance(eth.accounts[1]),'ether')
210
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现账户余额没有发生改变，此时交易已经提交到区块链，但还未被处理，这可以通过用 &lt;code class=&quot;highlighter-rouge&quot;&gt;txpool.status&lt;/code&gt; 命令可以看到本地交易池中有一个待确认的交易：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; txpool.status
{
  pending: 1,
  queued: 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;其中有一条pending的交易，pending表示已提交但还未被处理的交易。&lt;/p&gt;

&lt;p&gt;要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;miner.start(1);admin.sleepBlocks(1);miner.stop()
&amp;gt; web3.fromWei(eth.getBalance(eth.accounts[1]),'ether')
225.000378
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现账户收到了账户的钱，还多了5个以太币。其实多出的5个以太币是挖矿奖励。&lt;/p&gt;

&lt;h3 id=&quot;查看交易和区块&quot;&gt;查看交易和区块&lt;/h3&gt;

&lt;p&gt;查看当前区块总数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.blockNumber
99
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过区块号查看区块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; eth.getBlock(6)
{
  difficulty: 131328,
  extraData: &quot;0xd98301080a846765746888676f312e31302e328664617277696e&quot;,
  gasLimit: 3160033,
  gasUsed: 0,
  hash: &quot;0x9679d0dc01045c3d15cbf29241ae1cd6de2e5661d3387c0980f6397e3fd9ed2c&quot;,
  logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;,
  miner: &quot;0xfb9cc019fc650a1699d05b7fb564b83c3a72b64d&quot;,
  mixHash: &quot;0x05c369134eac2cb6227860b4ed11527b11825af3541712c5704914576c37c0a0&quot;,
  nonce: &quot;0x00168a9831624417&quot;,
  number: 6,
  parentHash: &quot;0xad68f0a581cf2144b8a05190b6310c7a9d945d9c338fd16b4708651b8813ad8b&quot;,
  receiptsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,
  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,
  size: 537,
  stateRoot: &quot;0xfaa0a4ffe160a2937b967f9780ae0de51a465bcce6a3f6f3aa24b903df3d44a0&quot;,
  timestamp: 1527602736,
  totalDifficulty: 918144,
  transactions: [],
  transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,
  uncles: []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过交易hash（hash 值包含在上面交易返回值中）查看交易：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eth.getTransaction(&quot;0x493e8aa2bcb6b2a362bdbd86b2c454279e14beea43b444aeb45c7f667bf572e2&quot;)
{
  blockHash: &quot;0xbe60f7ccddcb7cab39a7b932c0d89d37ac13ae14521cfdcb8ac359a5b6773655&quot;,
  blockNumber: 99,
  from: &quot;0xfb9cc019fc650a1699d05b7fb564b83c3a72b64d&quot;,
  gas: 90000,
  gasPrice: 18000000000,
  hash: &quot;0x493e8aa2bcb6b2a362bdbd86b2c454279e14beea43b444aeb45c7f667bf572e2&quot;,
  input: &quot;0x&quot;,
  nonce: 0,
  r: &quot;0x8da41e865d399fc4d8f813a39116e486db7658a04ea1f89ca0b7f44c02dd3c57&quot;,
  s: &quot;0x15edd22404460cfc5e86c9735774a02aad024bc8c369ec531e4485f1012cbcf6&quot;,
  to: &quot;0xc6b5702b15a3794374e28f41f36e1e8dbdd564df&quot;,
  transactionIndex: 0,
  v: &quot;0x37&quot;,
  value: 10000000000000000000
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;喜欢就star一下吧！👻👻👻&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作者原创，转载请注明出处，如有错误描述，请评论纠正，谢谢大家！🐳🐳🐳&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 31 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/31/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90+-+%E4%B8%8B%E8%BD%BD-%E7%BC%96%E8%AF%91+go-ethereum+-%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%93%BE/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/31/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90+-+%E4%B8%8B%E8%BD%BD-%E7%BC%96%E8%AF%91+go-ethereum+-%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%93%BE/</guid>
        
        <category>以太坊，私链</category>
        
        
      </item>
    
      <item>
        <title>Go实现Proof of Stake 共识机制</title>
        <description>&lt;h2 id=&quot;什么是-proof-of-stake&quot;&gt;什么是 Proof of Stake&lt;/h2&gt;

&lt;p&gt;在PoW中，节点之间通过hash的计算力来竞赛以获取下一个区块的记账权，而在PoS中，块是已经铸造好的，铸造的过程是基于每个节点(Node)愿意作为抵押的令牌(Token)数量。如果验证者愿意提供更多的令牌作为抵押品，他们就有更大的机会记账下一个区块并获得奖励。&lt;/p&gt;

&lt;h2 id=&quot;实现-proof-of-stake-主要功能点&quot;&gt;实现 Proof of Stake 主要功能点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;我们将有一个中心化的TCP服务节点，其他节点可以连接该服务器&lt;/li&gt;
  &lt;li&gt;最新的区块链状态将定期广播到每个节点&lt;/li&gt;
  &lt;li&gt;每个节点都能提议建立新的区块&lt;/li&gt;
  &lt;li&gt;基于每个节点的令牌数量，其中一个节点将随机地(以令牌数作为加权值)作为获胜者，并且将该区块添加到区块链中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实现-proof-of-stake&quot;&gt;实现 Proof of Stake&lt;/h2&gt;

&lt;h3 id=&quot;设置-tcp-服务器的端口&quot;&gt;设置 TCP 服务器的端口&lt;/h3&gt;

&lt;p&gt;新建 &lt;code class=&quot;highlighter-rouge&quot;&gt;.env&lt;/code&gt;，添加如下内容 &lt;code class=&quot;highlighter-rouge&quot;&gt;PORT=9000&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;安装依赖软件&quot;&gt;安装依赖软件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ go get github.com/davecgh/go-spew/spew

$ go get github.com/joho/godotenv
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spew&lt;/code&gt; 在控制台中格式化输出相应的结果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;godotenv&lt;/code&gt; 可以从我们项目的根目录的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.env&lt;/code&gt; 文件中读取数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;引入相应的包&quot;&gt;引入相应的包&lt;/h3&gt;

&lt;p&gt;新建 &lt;code class=&quot;highlighter-rouge&quot;&gt;main.go&lt;/code&gt;，引入相应的包&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;bufio&quot;
	&quot;crypto/sha256&quot;
	&quot;encoding/hex&quot;
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;log&quot;
	&quot;math/rand&quot;
	&quot;net&quot;
	&quot;os&quot;
	&quot;strconv&quot;
	&quot;sync&quot;
	&quot;time&quot;

	&quot;github.com/davecgh/go-spew/spew&quot;
	&quot;github.com/joho/godotenv&quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;全局变量&quot;&gt;全局变量&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Block represents each 'item' in the blockchain
type Block struct {
	Index     int
	Timestamp string
	BPM       int
	Hash      string
	PrevHash  string
	Validator string
}

// Blockchain is a series of validated Blocks
var Blockchain []Block
var tempBlocks []Block

// candidateBlocks handles incoming blocks for validation
var candidateBlocks = make(chan Block)

// announcements broadcasts winning validator to all nodes
var announcements = make(chan string)

var mutex = &amp;amp;sync.Mutex{}

// validators keeps track of open validators and balances
var validators = make(map[string]int)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Block&lt;/code&gt; 是每个区块的内容&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Blockchain&lt;/code&gt; 是我们的官方区块链，它只是一串经过验证的区块集合。每个区块中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PrevHash&lt;/code&gt; 与前面块的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt; 相比较，以确保我们的链是正确的。 &lt;code class=&quot;highlighter-rouge&quot;&gt;tempBlocks&lt;/code&gt; 是临时存储单元，在区块被选出来并添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;BlockChain&lt;/code&gt; 之前，临时存储在这里&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;candidateBlocks&lt;/code&gt; 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Block&lt;/code&gt; 的通道，任何一个节点在提出一个新块时都将它发送到这个通道&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;announcements&lt;/code&gt; 也是一个通道，我们的主Go TCP服务器将向所有节点广播最新的区块链&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mutex&lt;/code&gt;是一个标准变量，允许我们控制读/写和防止数据竞争&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;validators&lt;/code&gt; 是节点的存储map，同时也会保存每个节点持有的令牌数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;生成区块&quot;&gt;生成区块&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func generateBlock(oldBlock Block, BPM int, address string) (Block, error) {

	var newBlock Block

	t := time.Now()

	newBlock.Index = oldBlock.Index + 1
	newBlock.Timestamp = t.String()
	newBlock.BPM = BPM
	newBlock.PrevHash = oldBlock.Hash
	newBlock.Hash = calculateBlockHash(newBlock)
	newBlock.Validator = address

	return newBlock, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;generateBlock&lt;/code&gt; 是用来创建新块的。
&lt;code class=&quot;highlighter-rouge&quot;&gt;newBlock.PrevHash&lt;/code&gt; 存储的是上一个区块的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;newBlock.Hash&lt;/code&gt; 是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;calculateBlockHash(newBlock)&lt;/code&gt; 生成的 Hash 。
&lt;code class=&quot;highlighter-rouge&quot;&gt;newBlock.Validator&lt;/code&gt; 存储的是获取记账权的节点地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SHA256 hasing
// calculateHash is a simple SHA256 hashing function
func calculateHash(s string) string {
	h := sha256.New()
	h.Write([]byte(s))
	hashed := h.Sum(nil)
	return hex.EncodeToString(hashed)
}

//calculateBlockHash returns the hash of all block information
func calculateBlockHash(block Block) string {
	record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash
	return calculateHash(record)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;calculateHash&lt;/code&gt; 函数会接受一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; ，并且返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt;SHA256 hash&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;calculateBlockHash&lt;/code&gt; 是对一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; 进行 &lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;，将一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; 的所有字段连接到一起后，再调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;calculateHash&lt;/code&gt; 将字符串转为 &lt;code class=&quot;highlighter-rouge&quot;&gt;SHA256 hash&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;验证区块&quot;&gt;验证区块&lt;/h3&gt;

&lt;p&gt;我们通过检查 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 来确保它们按预期递增。我们也检查以确保我们 &lt;code class=&quot;highlighter-rouge&quot;&gt;PrevHash&lt;/code&gt; 的确与 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt; 前一个区块相同。最后，我们希望通过在当前块上 &lt;code class=&quot;highlighter-rouge&quot;&gt;calculateBlockHash&lt;/code&gt; 再次运行该函数来检查当前块的散列。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// isBlockValid makes sure block is valid by checking index
// and comparing the hash of the previous block
func isBlockValid(newBlock, oldBlock Block) bool {
	if oldBlock.Index+1 != newBlock.Index {
		return false
	}

	if oldBlock.Hash != newBlock.PrevHash {
		return false
	}

	if calculateBlockHash(newBlock) != newBlock.Hash {
		return false
	}

	return true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;验证者&quot;&gt;验证者&lt;/h3&gt;

&lt;p&gt;当一个验证者连接到我们的TCP服务，我们需要提供一些函数达到以下目标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输入令牌的余额（之前提到过，我们不做钱包等逻辑)&lt;/li&gt;
  &lt;li&gt;接收区块链的最新广播&lt;/li&gt;
  &lt;li&gt;接收验证者赢得区块的广播信息&lt;/li&gt;
  &lt;li&gt;将自身节点添加到全局的验证者列表中（validators)&lt;/li&gt;
  &lt;li&gt;输入Block的BPM数据- BPM是每个验证者的人体脉搏值&lt;/li&gt;
  &lt;li&gt;提议创建一个新的区块&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func handleConn(conn net.Conn) {
	defer conn.Close()

	go func() {
		for {
			msg := &amp;lt;-announcements
			io.WriteString(conn, msg)
		}
	}()
	// 验证者地址
	var address string

	// 验证者输入他所拥有的 tokens，tokens 的值越大，越容易获得新区块的记账权
	io.WriteString(conn, &quot;Enter token balance:&quot;)
	scanBalance := bufio.NewScanner(conn)
	for scanBalance.Scan() {
		// 获取输入的数据，并将输入的值转为 int
		balance, err := strconv.Atoi(scanBalance.Text())
		if err != nil {
			log.Printf(&quot;%v not a number: %v&quot;, scanBalance.Text(), err)
			return
		}
		t := time.Now()
		// 生成验证者的地址
		address = calculateHash(t.String())
		// 将验证者的地址和token 存储到 validators
		validators[address] = balance
		fmt.Println(validators)
		break
	}

	io.WriteString(conn, &quot;\nEnter a new BPM:&quot;)

	scanBPM := bufio.NewScanner(conn)

	go func() {
		for {
			// take in BPM from stdin and add it to blockchain after conducting necessary validation
			for scanBPM.Scan() {
				bpm, err := strconv.Atoi(scanBPM.Text())
				// 如果验证者试图提议一个被污染（例如伪造）的block，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表validators中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。
				if err != nil {
					log.Printf(&quot;%v not a number: %v&quot;, scanBPM.Text(), err)
					delete(validators, address)
					conn.Close()
				}

				mutex.Lock()
				oldLastIndex := Blockchain[len(Blockchain)-1]
				mutex.Unlock()

				// 创建新的区块，然后将其发送到 candidateBlocks 通道
				newBlock, err := generateBlock(oldLastIndex, bpm, address)
				if err != nil {
					log.Println(err)
					continue
				}
				if isBlockValid(newBlock, oldLastIndex) {
					candidateBlocks &amp;lt;- newBlock
				}
				io.WriteString(conn, &quot;\nEnter a new BPM:&quot;)
			}
		}
	}()

	// 循环会周期性的打印出最新的区块链信息
	for {
		time.Sleep(time.Minute)
		mutex.Lock()
		output, err := json.Marshal(Blockchain)
		mutex.Unlock()
		if err != nil {
			log.Fatal(err)
		}
		io.WriteString(conn, string(output)+&quot;\n&quot;)
	}

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;io.WriteString(conn, &quot;Enter token balance:&quot;)&lt;/code&gt;允许验证者输入他持有的令牌数量，然后，该验证者被分配一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;SHA256&lt;/code&gt;地址，随后该验证者地址和验证者的令牌数被添加到验证者列表&lt;code class=&quot;highlighter-rouge&quot;&gt;validators&lt;/code&gt; 中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着我们输入BPM，验证者的脉搏值，并创建一个单独的Go协程来处理这块儿逻辑&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;delete(validators, address)&lt;/code&gt; 如果验证者试图提议一个被污染（例如伪造）的 &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt;，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表 &lt;code class=&quot;highlighter-rouge&quot;&gt;validators&lt;/code&gt; 中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;正是因为这种抵押令牌的机制，使得PoS协议是一种更加可靠的机制。如果一个人试图伪造和破坏，那么他将被抓住，并且失去所有抵押和未来的权益，因此对于恶意者来说，是非常大的威慑。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着，我们用 &lt;code class=&quot;highlighter-rouge&quot;&gt;generateBlock&lt;/code&gt; 函数创建一个新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt;，然后将其发送到 &lt;code class=&quot;highlighter-rouge&quot;&gt;candidateBlocks&lt;/code&gt; 通道进行进一步处理。将&lt;code class=&quot;highlighter-rouge&quot;&gt;Block&lt;/code&gt; 发送到通道使用的语法: &lt;code class=&quot;highlighter-rouge&quot;&gt;candidateBlocks &amp;lt;- newBlock&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后会循环打印出最新的区块链，这样每个验证者都能获知最新的状态。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;选择获取记账权的节点&quot;&gt;选择获取记账权的节点&lt;/h3&gt;

&lt;p&gt;下面是PoS的主要逻辑。我们需要编写代码以实现获胜验证者的选择;他们所持有的令牌数量越高，他们就越有可能被选为胜利者。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// pickWinner creates a lottery pool of validators and chooses the validator who gets to forge a block to the blockchain
// by random selecting from the pool, weighted by amount of tokens staked
func pickWinner() {
	time.Sleep(30 * time.Second)
	mutex.Lock()
	temp := tempBlocks
	mutex.Unlock()

	lotteryPool := []string{}
	if len(temp) &amp;gt; 0 {

		// slightly modified traditional proof of stake algorithm
		// from all validators who submitted a block, weight them by the number of staked tokens
		// in traditional proof of stake, validators can participate without submitting a block to be forged
	OUTER:
		for _, block := range temp {
			// if already in lottery pool, skip
			for _, node := range lotteryPool {
				if block.Validator == node {
					continue OUTER
				}
			}

			// lock list of validators to prevent data race
			mutex.Lock()
			setValidators := validators
			mutex.Unlock()

			// 获取验证者的tokens
			k, ok := setValidators[block.Validator]
			if ok {
				// 向 lotteryPool 追加 k 条数据，k 代表的是当前验证者的tokens
				for i := 0; i &amp;lt; k; i++ {
					lotteryPool = append(lotteryPool, block.Validator)
				}
			}
		}

		// 通过随机获得获胜节点的地址
		s := rand.NewSource(time.Now().Unix())
		r := rand.New(s)
		lotteryWinner := lotteryPool[r.Intn(len(lotteryPool))]

		// 把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息
		for _, block := range temp {
			if block.Validator == lotteryWinner {
				mutex.Lock()
				Blockchain = append(Blockchain, block)
				mutex.Unlock()
				for _ = range validators {
					announcements &amp;lt;- &quot;\nwinning validator: &quot; + lotteryWinner + &quot;\n&quot;
				}
				break
			}
		}
	}

	mutex.Lock()
	tempBlocks = []Block{}
	mutex.Unlock()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每隔30秒，我们选出一个胜利者，这样对于每个验证者来说，都有时间提议新的区块，参与到竞争中来。接着创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;lotteryPool&lt;/code&gt;，它会持有所有验证者的地址，这些验证者都有机会成为一个胜利者。然后，对于提议块的暂存区域，我们会通过&lt;code class=&quot;highlighter-rouge&quot;&gt;if len(temp) &amp;gt; 0&lt;/code&gt;来判断是否已经有了被提议的区块。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;OUTER FOR&lt;/code&gt;循环中，要检查暂存区域是否和 &lt;code class=&quot;highlighter-rouge&quot;&gt;lotteryPool&lt;/code&gt; 中存在同样的验证者，如果存在，则跳过。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在以 &lt;code class=&quot;highlighter-rouge&quot;&gt;k, ok := setValidators[block.Validator]&lt;/code&gt;开始的代码块中，我们确保了从&lt;code class=&quot;highlighter-rouge&quot;&gt;temp&lt;/code&gt;中取出来的验证者都是合法的，即这些验证者在验证者列表&lt;code class=&quot;highlighter-rouge&quot;&gt;validators&lt;/code&gt;已存在。若合法，则把该验证者加入到&lt;code class=&quot;highlighter-rouge&quot;&gt;lotteryPool&lt;/code&gt;中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;那么我们怎么根据这些验证者持有的令牌数来给予他们合适的随机权重呢？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;首先，用验证者的令牌填充&lt;code class=&quot;highlighter-rouge&quot;&gt;lotteryPool&lt;/code&gt;数组，例如一个验证者有100个令牌，那么在&lt;code class=&quot;highlighter-rouge&quot;&gt;lotteryPool&lt;/code&gt;中就将有100个元素填充；如果有1个令牌，那么将仅填充1个元素。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;然后，从&lt;code class=&quot;highlighter-rouge&quot;&gt;lotteryPool&lt;/code&gt;中随机选择一个元素，元素所属的验证者即是胜利者，把胜利验证者的地址赋值给lotteryWinner。这里能够看出来，如果验证者持有的令牌越多，那么他在数组中的元素也越多，他获胜的概率就越大；同时，持有令牌很少的验证者，也是有概率获胜的。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着我们把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息：&lt;code class=&quot;highlighter-rouge&quot;&gt;announcements &amp;lt;- &quot;\nwinning validator: &quot; + lotteryWinner + &quot;\n&quot; &lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后，清空tempBlocks，以便下次提议的进行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;主函数&quot;&gt;主函数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
	err := godotenv.Load()
	if err != nil {
		log.Fatal(err)
	}

	// 创建初始区块
	t := time.Now()
	genesisBlock := Block{}
	genesisBlock = Block{0, t.String(), 0, calculateBlockHash(genesisBlock), &quot;&quot;, &quot;&quot;}
	spew.Dump(genesisBlock)
	Blockchain = append(Blockchain, genesisBlock)

	httpPort := os.Getenv(&quot;PORT&quot;)

	// 启动 TCP 服务
	server, err := net.Listen(&quot;tcp&quot;, &quot;:&quot;+httpPort)
	if err != nil {
		log.Fatal(err)
	}
	log.Println(&quot;HTTP Server Listening on port :&quot;, httpPort)
	defer server.Close()

	// 启动了一个Go routine 从 candidateBlocks 通道中获取提议的区块，然后填充到临时缓冲区 tempBlocks 中
	go func() {
		for candidate := range candidateBlocks {
			mutex.Lock()
			tempBlocks = append(tempBlocks, candidate)
			mutex.Unlock()
		}
	}()

	// 启动了一个Go routine 完成 pickWinner 函数
	go func() {
		for {
			pickWinner()
		}
	}()

	// 接收验证者节点的连接
	for {
		conn, err := server.Accept()
		if err != nil {
			log.Fatal(err)
		}
		go handleConn(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;godotenv.Load()&lt;/code&gt; 会解析 &lt;code class=&quot;highlighter-rouge&quot;&gt;.env&lt;/code&gt; 文件并将相应的Key/Value对都放到环境变量中，通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;os.Getenv&lt;/code&gt; 获取&lt;/li&gt;
  &lt;li&gt;然后创建一个创世区块genesisBlock，形成了区块链。&lt;/li&gt;
  &lt;li&gt;接着启动了Tcp服务，等待所有验证者的连接。&lt;/li&gt;
  &lt;li&gt;启动了一个Go协程从 &lt;code class=&quot;highlighter-rouge&quot;&gt;candidateBlocks&lt;/code&gt; 通道中获取提议的区块，然后填充到临时缓冲区 &lt;code class=&quot;highlighter-rouge&quot;&gt;tempBlocks&lt;/code&gt; 中，最后启动了另外一个Go协程来完成 &lt;code class=&quot;highlighter-rouge&quot;&gt;pickWinner&lt;/code&gt; 函数。&lt;/li&gt;
  &lt;li&gt;最后的for循环，用来接收验证者节点的连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;运行&quot;&gt;运行&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;go run main.go&lt;/code&gt; 启动您的Go程序和TCP服务器，并会打印出初始区块的信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ go run main.go
(main.Block) {
 Index: (int) 0,
 Timestamp: (string) (len=50) &quot;2018-05-08 16:45:27.14287 +0800 CST m=+0.000956793&quot;,
 BPM: (int) 0,
 Hash: (string) (len=64) &quot;96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7&quot;,
 PrevHash: (string) &quot;&quot;,
 Validator: (string) &quot;&quot;
}
2018/05/08 16:45:27 HTTP Server Listening on port : 9000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打开新的终端，运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;nc localhost 9000&lt;/code&gt;，
输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;tokens&lt;/code&gt; , 然后输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;BPM&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://olgjbx93m.bkt.clouddn.com/WX20180508-165429.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以打开多个终端，输入不同的 &lt;code class=&quot;highlighter-rouge&quot;&gt;tokens&lt;/code&gt; ,来检验 PoS 算法&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://olgjbx93m.bkt.clouddn.com/WX20180508-165704.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/shuailaotou/proofOfStake&quot;&gt;github源代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;喜欢就star一下吧！👻👻👻&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有错误描述，请评论纠正，谢谢大家！🐳🐳🐳&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 31 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/31/Go%E5%AE%9E%E7%8E%B0Proof-of-Stake-%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/31/Go%E5%AE%9E%E7%8E%B0Proof-of-Stake-%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</guid>
        
        <category>POS</category>
        
        
      </item>
    
      <item>
        <title>使用Go实现Proof-of-Work 共识机制</title>
        <description>&lt;h2 id=&quot;什么是-proof-of-work&quot;&gt;什么是 Proof-of-Work&lt;/h2&gt;

&lt;p&gt;Proof-of-Work 简称 PoW，即为工作量证明。通过计算一个数值（ nonce ），使得拼揍上交易数据后内容的 Hash 值满足规定的上限。在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。&lt;/p&gt;

&lt;p&gt;如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。
网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。&lt;/p&gt;

&lt;p&gt;假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。&lt;/p&gt;

&lt;h2 id=&quot;工作量证明的优缺点&quot;&gt;工作量证明的优缺点&lt;/h2&gt;

&lt;p&gt;优点：完全去中心化，节点自由进出；&lt;/p&gt;

&lt;p&gt;缺点：目前bitcoin已经吸引全球大部分的算力，其它再用Pow共识机制的区块链应用很难获得相同的算力来保障自身的安全；挖矿造成大量的资源浪费；共识达成的周期较长，不适合商业应用&lt;/p&gt;

&lt;h2 id=&quot;工作量证明的简单的例子&quot;&gt;工作量证明的简单的例子&lt;/h2&gt;

&lt;p&gt;举个例子，给定的一个基本的字符串”Hello, world!”，我们给出的工作量要求是，可以在这个字符串后面添加一个叫做nonce的整数值，对变更后（添加nonce)的字符串进行SHA256哈希运算，如果得到的哈希结果（以16进制的形式表示）是以”0000”开头的，则验证通过。为了达到这个工作量证明的目标。我们需要不停的递增nonce值，对得到的新字符串进行SHA256哈希运算。按照这个规则，我们需要经过4251次计算才能找到恰好前4位为0的哈希散列。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;Hello, world!0&quot; =&amp;gt; 1312af178c253f84028d480a6adc1e25e81caa44c749ec81976192e2ec934c64
&quot;Hello, world!1&quot; =&amp;gt; e9afc424b79e4f6ab42d99c81156d3a17228d6e1eef4139be78e948a9332a7d8
&quot;Hello, world!2&quot; =&amp;gt; ae37343a357a8297591625e7134cbea22f5928be8ca2a32aa475cf05fd4266b7
...
&quot;Hello, world!4248&quot; =&amp;gt; 6e110d98b388e77e9c6f042ac6b497cec46660deef75a55ebc7cfdf65cc0b965
&quot;Hello, world!4249&quot; =&amp;gt; c004190b822f1669cac8dc37e761cb73652e7832fb814565702245cf26ebb9e6
&quot;Hello, world!4250&quot; =&amp;gt; 0000c3af42fc31103f1fdc0151fa747ff87349a4714df7cc52ea464e12dcd4e9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;实现-proof-of-work-共识机制&quot;&gt;实现 Proof-of-Work 共识机制&lt;/h2&gt;

&lt;h3 id=&quot;安装依赖软件&quot;&gt;安装依赖软件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ go get github.com/davecgh/go-spew/spew

$ go get github.com/gorilla/mux

$ go get github.com/joho/godotenv
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spew&lt;/code&gt; 在控制台中格式化输出相应的结果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gorilla/mux&lt;/code&gt; 是编写web处理程序的流行软件包。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;godotenv&lt;/code&gt; 可以从我们项目的根目录的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.env&lt;/code&gt; 文件中读取数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实现-pow-共识机制&quot;&gt;实现 PoW 共识机制&lt;/h3&gt;

&lt;p&gt;新建 &lt;code class=&quot;highlighter-rouge&quot;&gt;.env&lt;/code&gt; ，添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;ADDR=8080&lt;/code&gt;
新建 &lt;code class=&quot;highlighter-rouge&quot;&gt;main.go&lt;/code&gt;，引入相应的包&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
        &quot;crypto/sha256&quot;
        &quot;encoding/hex&quot;
        &quot;encoding/json&quot;
        &quot;fmt&quot;
        &quot;io&quot;
        &quot;log&quot;
        &quot;net/http&quot;
        &quot;os&quot;
        &quot;strconv&quot;
        &quot;strings&quot;
        &quot;sync&quot;
        &quot;time&quot;

        &quot;github.com/davecgh/go-spew/spew&quot;
        &quot;github.com/gorilla/mux&quot;
        &quot;github.com/joho/godotenv&quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;定义区块&quot;&gt;定义区块&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const difficulty = 1

type Block struct {
        Index      int
        Timestamp  string
        BPM        int
        Hash       string
        PrevHash   string
        Difficulty int
        Nonce      string
}

var Blockchain []Block

type Message struct {
        BPM int
}

var mutex = &amp;amp;sync.Mutex{}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;difficulty&lt;/code&gt; 代表难度系数，如果赋值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;，则需要判断生成区块时所产生的 Hash 前缀至少包含1个 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Block&lt;/code&gt; 代表区块的结构体。
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 是区块链中数据记录的位置&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Timestamp&lt;/code&gt; 是自动确定的，并且是写入数据的时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BPM&lt;/code&gt; 是每分钟跳动的次数，是你的脉率&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt; 是代表这个数据记录的SHA256标识符&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PrevHash&lt;/code&gt; 是链中上一条记录的SHA256标识符&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Difficulty&lt;/code&gt; 是当前区块的难度系数&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Nonce&lt;/code&gt; 是 PoW 挖矿中符合条件的数字&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Blockchain&lt;/code&gt; 是存放区块数据的集合&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt; 是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt; 请求传递的数据&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mutex&lt;/code&gt; 是为了防止同一时间产生多个区块&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;生成区块&quot;&gt;生成区块&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func generateBlock(oldBlock Block, BPM int) Block {
        var newBlock Block

        t := time.Now()

        newBlock.Index = oldBlock.Index + 1
        newBlock.Timestamp = t.String()
        newBlock.BPM = BPM
        newBlock.PrevHash = oldBlock.Hash
        newBlock.Difficulty = difficulty

        for i := 0; ; i++ {
                hex := fmt.Sprintf(&quot;%x&quot;, i)
                newBlock.Nonce = hex
                if !isHashValid(calculateHash(newBlock), newBlock.Difficulty) {
                        fmt.Println(calculateHash(newBlock), &quot; do more work!&quot;)
                        time.Sleep(time.Second)
                        continue
                } else {
                        fmt.Println(calculateHash(newBlock), &quot; work done!&quot;)
                        newBlock.Hash = calculateHash(newBlock)
                        break
                }

        }
        return newBlock
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newBlock&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PrevHash&lt;/code&gt; 存储的上一个区块的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for 循环&lt;/code&gt; 通过循环改变 &lt;code class=&quot;highlighter-rouge&quot;&gt;Nonce&lt;/code&gt;，然后选出符合相应难度系数的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Nonce&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;isHashValid&lt;/code&gt; 判断 hash，是否满足当前的难度系数。如果难度系数是2，则当前hash的前缀有2个0。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func isHashValid(hash string, difficulty int) bool {
        prefix := strings.Repeat(&quot;0&quot;, difficulty)
        return strings.HasPrefix(hash, prefix)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strings.Repeat(&quot;0&quot;, difficulty)&lt;/code&gt; 复制 &lt;code class=&quot;highlighter-rouge&quot;&gt;difficulty&lt;/code&gt; 个&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，并返回新字符串，当 difficulty 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt; ，则 prefix 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;00&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strings.HasPrefix(hash, prefix)&lt;/code&gt; 判断字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt; 是否包含前缀 &lt;code class=&quot;highlighter-rouge&quot;&gt;prefix&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;calculateHash&lt;/code&gt; 根据设定的规则，生成 Hash 值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func calculateHash(block Block) string {
        record := strconv.Itoa(block.Index) + block.Timestamp + strconv.Itoa(block.BPM) + block.PrevHash + block.Nonce
        h := sha256.New()
        h.Write([]byte(record))
        hashed := h.Sum(nil)
        return hex.EncodeToString(hashed)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;验证区块&quot;&gt;验证区块&lt;/h4&gt;

&lt;p&gt;我们通过检查 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 来确保它们按预期递增。我们也检查以确保我们 &lt;code class=&quot;highlighter-rouge&quot;&gt;PrevHash&lt;/code&gt; 的确与 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt; 前一个区块相同。最后，我们希望通过在当前块上 &lt;code class=&quot;highlighter-rouge&quot;&gt;calculateHash&lt;/code&gt; 再次运行该函数来检查当前块的散列。让我们写一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;isBlockValid&lt;/code&gt; 函数来完成所有这些事情并返回一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func isBlockValid(newBlock, oldBlock Block) bool {
        if oldBlock.Index+1 != newBlock.Index {
                return false
        }

        if oldBlock.Hash != newBlock.PrevHash {
                return false
        }

        if calculateHash(newBlock) != newBlock.Hash {
                return false
        }

        return true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;web-服务器&quot;&gt;web 服务器&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func run() error {
        mux := makeMuxRouter()
        httpAddr := os.Getenv(&quot;ADDR&quot;)
        log.Println(&quot;Listening on &quot;, os.Getenv(&quot;ADDR&quot;))
        s := &amp;amp;http.Server{
                Addr:           &quot;:&quot; + httpAddr,
                Handler:        mux,
                ReadTimeout:    10 * time.Second,
                WriteTimeout:   10 * time.Second,
                MaxHeaderBytes: 1 &amp;lt;&amp;lt; 20,
        }

        if err := s.ListenAndServe(); err != nil {
                return err
        }

        return nil
}

func makeMuxRouter() http.Handler {
        muxRouter := mux.NewRouter()
        muxRouter.HandleFunc(&quot;/&quot;, handleGetBlockchain).Methods(&quot;GET&quot;)
        muxRouter.HandleFunc(&quot;/&quot;, handleWriteBlock).Methods(&quot;POST&quot;)
        return muxRouter
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;makeMuxRouter&lt;/code&gt; 主要定义路由处理，当收到 &lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt; 请求，就会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;handleGetBlockchain&lt;/code&gt; 方法。当收到 &lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt; 请求，就会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;handleWriteBlock&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;handleGetBlockchain&lt;/code&gt; 获取所有区块的列表信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func handleGetBlockchain(w http.ResponseWriter, r *http.Request) {
        bytes, err := json.MarshalIndent(Blockchain, &quot;&quot;, &quot;  &quot;)
        if err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }
        io.WriteString(w, string(bytes))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;handleWriteBlock&lt;/code&gt; 主要是生成新的区块。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func handleWriteBlock(w http.ResponseWriter, r *http.Request) {
	w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
	var m Message

	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&amp;amp;m); err != nil {
			respondWithJSON(w, r, http.StatusBadRequest, r.Body)
			return
	}   
	defer r.Body.Close()

	//ensure atomicity when creating new block
	mutex.Lock()
	newBlock := generateBlock(Blockchain[len(Blockchain)-1], m.BPM)
	mutex.Unlock()

	if isBlockValid(newBlock, Blockchain[len(Blockchain)-1]) {
			Blockchain = append(Blockchain, newBlock)
			spew.Dump(Blockchain)
	}   

	respondWithJSON(w, r, http.StatusCreated, newBlock)

}

func respondWithJSON(w http.ResponseWriter, r *http.Request, code int, payload interface{}) {
	w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
	response, err := json.MarshalIndent(payload, &quot;&quot;, &quot;  &quot;)
	if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte(&quot;HTTP 500: Internal Server Error&quot;))
			return
	}
	w.WriteHeader(code)
	w.Write(response)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;主函数&quot;&gt;主函数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
	err := godotenv.Load()
	if err != nil {
			log.Fatal(err)
	}   

	go func() {
			t := time.Now()
			genesisBlock := Block{}
			genesisBlock = Block{0, t.String(), 0, calculateHash(genesisBlock), &quot;&quot;, difficulty, &quot;&quot;} 
			spew.Dump(genesisBlock)

			mutex.Lock()
			Blockchain = append(Blockchain, genesisBlock)
			mutex.Unlock()
	}() 
	log.Fatal(run())

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;godotenv.Load()&lt;/code&gt; 允许我们从 根目录的文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;.env&lt;/code&gt; 读取相应的变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;genesisBlock&lt;/code&gt; 创建初始区块。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt; 启动 web 服务&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;启动web服务器&quot;&gt;启动web服务器&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ go run main.go
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;Postman&lt;/code&gt;软件模拟网络请求。&lt;/p&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt; 访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8080&lt;/code&gt; 可以添加新的区块信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://olgjbx93m.bkt.clouddn.com/WX20180507-162511.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以在终端查看挖矿过程，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://olgjbx93m.bkt.clouddn.com/WX20180507-162255.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt; 访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8080&lt;/code&gt; 可以获取区块链信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://olgjbx93m.bkt.clouddn.com/WX20180507-162527.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/shuailaotou/proofOfWork&quot;&gt;使用 go 实现 Proof-of-Work 共识机制&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 23 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/23/%E4%BD%BF%E7%94%A8Go%E5%AE%9E%E7%8E%B0ProofofWork%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/23/%E4%BD%BF%E7%94%A8Go%E5%AE%9E%E7%8E%B0ProofofWork%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</guid>
        
        <category>pow</category>
        
        
      </item>
    
      <item>
        <title>分布式系统原理介绍</title>
        <description>&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.1   模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;分布式系统在分布式层面的基本问题模型,为了控制问题的规模，精简了分布式系统的模型。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-19-01.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.1  节点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;节点&lt;/code&gt;是指一个可以独立按照分布式协议完成的一组逻辑的程序个体，一个节点往往是一个操作系统上的进程。
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.2 通信&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
节点与节点之间是完全独立、相互隔离的，节点之间传递信息的唯一方式是通过不可靠的网络进行通信。即一个节点可以向其他节点通过网络发送消息，但是发送消息的节点无法确认消息是否被接受节点完整正确的收到。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.3 存储&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;节点可以通过将数据写入与节点在同一台机器的本地存储设备保存数据。通常的存储设备有磁盘，SSD等存储、读取数据的节点称为有状态的节点，反之称为无状态节点。如果某个节点A存储数据的方式是将数据通过网络发送到另一个节点B，由节点B负责将数据存储到节点B的本地存储设备，那么不能认为节点A是有状态的节点，而只有节点B是有状态的节点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.4  异常&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;分布式系统的核心问题之一就是处理各种异常情况&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1.1.4.1 机器宕机&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;当发生宕机的时候，节点无法进入正常的工作状态，称之为&lt;code class=&quot;highlighter-rouge&quot;&gt;不可用状态&lt;/code&gt;。机器重启后，节点可以通过读取本地存储设备中的信息或者通过读取其他节点数据的方式恢复内存信息，从而恢复到某一宕机前的状态。
无状态的节点可以立即恢复&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.4.2 网络异常&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;节点通过不可靠的网络进行通信&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.4.2.1 消息丢失&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;消息丢失是最常见的网络异常，在发生网络拥堵、路由变动、设备异常等情况时，都可能发生发送的数据丢失。
如果某些节点的直接的网络通信正常或丢包率在合理范围内，而某些 节点之间始终无法正常通信，则称这种特殊的网络异常为“网络分化”(network partition)。网络分 化是一类常见的网络异常，尤其当分布式系统部署在多个机房之间时。图 1-1 中，用虚线分割了两 片节点，这两片节点之间彼此完全无法通信，即出现了&lt;code class=&quot;highlighter-rouge&quot;&gt;“网络分化”&lt;/code&gt;
例 1.1:某分布式系统部署于两个机房，机房间使用内部独立光纤链路。由于机房间的光纤链路 交割调整，两个机房间通信中断，期间，各机房内的节点相互通信正常。更为严重的是，所有的英 特网用户都可以正常访问两个机房内对外服务节点。本文后续将讨论出现这种严重的网络分化时， 对分布式系统的设计带来的&lt;code class=&quot;highlighter-rouge&quot;&gt;巨大挑战&lt;/code&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.4.2.2 消息乱序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;消息乱序是指节点发送的网络消息有一定的概率不是按照发送时的顺序依次到达目的节点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.4.2.3 数据错误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;网络上传输的数据有可能发生比特错误，从而造成数据错误&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.4.2.4 不可靠的TCP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;TCP也会因为一些极端情况变得不可靠&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.4.3 分布式系统的三态&lt;/strong&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;一个节点A向另一个节点B发送消息，节点B根据收到的消息内容完成某些操作，并将操作的结果通过另一个消息返回给节点A，那么这个RPC的执行结果就有三种状态：“成功”，“失败”，“超时（未知）”，称之为分布式系统的三态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.4.4 存储数据丢失&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据丢失指节点存储的数据不可被读取或读取出的数据错误。数据丢失是另一类常见的异常。 尤其是使用机械硬盘做存储介质时，硬盘损坏的概率较大。对于有状态节点来说，数据丢失意味着 状态丢失，通常只能从其他节点读取、恢复存储的状态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1.4.6 异常的处理原则&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;被大量工程实践所检验的异常处理黄金原则是：任何在设计阶段考虑到的异常情况一定会在系统实际运行中发生，但在系统实际运行遇到的异常却很可能在设计时未能考虑，所以，除非需求指标允许，在系统设计时不能放过任何异常情况。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 副本&lt;/strong&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2.1 副本的概念&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
副本是指在分布式系统中为数据或服务提供的冗余。对于数据副本指在不同的节点上持久化同一份数据，当出现某一个节点的存储数据丢失时，可以从副本上读到数据。
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2.1 副本一致性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
分布式系统通过副本协议，使得从系统外部读取系统内部各个副本的数据 在一定的约束条件下相同，称之为&lt;code class=&quot;highlighter-rouge&quot;&gt;副本一致性&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3 衡量分布式系统的指标&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;评价分布式系统有一些常用的指标，包括性能，可用性，可扩展性，一致性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3.1 性能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;常见的性能指标&lt;/code&gt;有系统的吞吐能力，指系统在某段时间可以处理的数据总量，通常可以用系统美妙处理的总的数据量来衡量；系统的响应延迟，指系统完成某一功能需要使用的时间；系统的并发能力，指系统可以同时完成某一功能的能力，通常也用QPS来衡量。以上三个性能指标往往会相互制约，追求高吞吐的系统，往往很难做到低延迟；系统平均响应时间较长时，也很难提高QPS。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3.2 可用性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;系统的可用性&lt;/code&gt;指系统在面对各种异常时可以正确提供服务的能力。系统的可用性可以用系统停服务的时间与正常服务时间的比例衡量，也可以用某功能的失败次数与成功次数的比例衡量。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3.3 可扩展性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;系统的可用性&lt;/code&gt;指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性。可扩展性时分布式系统的特有性质。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3.4 一致性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题&lt;/p&gt;

&lt;h3 id=&quot;2分布式系统原理&quot;&gt;2.分布式系统原理&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2.1 数据分布方式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所谓分布式系统顾名思义就是利用多台计算机协同解决单台计算机所不能解决的计算、存储等问题&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2.1.1 哈希方式&lt;/strong&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;哈希方式是最常见的数据分布方式，其方法是按照数据的某一特征计算哈希值，并将哈希值与机器中的机器建立映射关系，从而将不同哈希值的数据分布到不同的机器上。所谓数据特征可以是key -value 系统中的key，也可以是其他与应用业务逻辑相关的值。例如，一种常见的哈希方式是按 数据属于的用户 id 计算哈希值，集群中的服务器按 0 到机器数减 1 编号，哈希值除以服务器的个数， 结果的余数作为处理该数据的服务器编号。工程中，往往需要考虑服务器的副本冗余，将每数台(例 如 3)服务器组成一组，用哈希值除以总的组数，其余数为服务器组的编号。图 2-1 给出了哈希方 式分数据的一个例子，将数据按哈希值分配到 4 个节点上。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-19-02.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.2 按数据范围分布&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
按数据范围分布是另一种常见的数据分布方式，将数据按特征值的值域范围划分为不同的区间，使得集群中每台服务器处理不同区间的数据。例 2.1.1:已知某系统中用户 id 的值域范围是[1,100)，集群有 3 台服务器，使用按数据范围划分 数据的数据分布方式。将用户 id 的值域分为三个区间[1, 33),，[33, 90)，[90, 100)分别由 3 台服务器 负责处理。图 2-3 给出这个例子的示意图。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-19-03.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;与哈希分布数据的方式只需要记录哈希函数及分桶个数(机器数)不同，按数据范围分布数据 需要记录所有的数据分布情况。一般的，往往需要使用专门的服务器在内存中维护数据分布信息， 称这种数据的分布信息为一种元信息。甚至对于大规模的集群，由于元信息的规模非常庞大，单台
计算机无法独立维护，需要使用多台机器作为元信息服务器。
&lt;br /&gt;
 使用范围分布数据的方式的最大优点就是可以灵活的根据数据量的具体情况拆分原有数据区间， 拆分后的数据区间可以迁移到其他机器，一旦需要集群完成负载均衡时，与哈希方式相比非常灵活。 另外，当集群需要扩容时，可以随意添加机器，而不限为倍增的方式，只需将原机器上的部分数据 分区迁移到新加入的机器上就可以完成集群扩容。
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2.1.3 按数据量分布&lt;/strong&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;另一类常用的数据分布方式则是按照数据量分布数据。与哈希方式和按数据范围方式不同，数 据量分布数据与具体的数据特征无关，而是将数据视为一个顺序增长的文件，并将这个文件按照某 一较为固定的大小划分为若干数据块(chunk)，不同的数据块分布到不同的服务器上。与按数据范 围分布数据的方式类似的是，按数据量分布数据也需要记录数据块的具体分布情况，并将该分布信 息作为元数据使用元数据服务器管理。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2.1.4 一致性哈希&lt;/strong&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;一致性哈希(consistent hashing)是另一个种在工程中使用较为广泛的数据分布方式。一致性哈
希最初在 P2P 网络中作为分布式哈希表(DHT)的常用数据分布算法。一致性哈希的基本方式是使用一个哈希函数计算数据或数据特征的哈希值，令该哈希函数的输出值域为一个封闭的环，即哈希 函数输出的最大值是最小值的前序。将节点随机分布到这个环上，每个节点负责处理从自己开始顺 时针至下一个节点的全部哈希值域上的数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.5 副本与数据分布&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设有 3 个副 本机器，某时刻其中某台机器磁盘损坏，丢失了全部数据，此时使用新的机器替代故障机器，为了 是的新机器也可以提供服务，需要从正常的两台机器上拷贝数据。此种全盘拷贝数据一般都较为消 耗资源，为了不影响服务质量，实践中往往采用两种方式:一、将一台可用的副本机器下线，专门 作为数据源拷贝数据，这样做的缺点是造成实际正常副本数只有 1 个，对数据安全性造成巨大隐患， 且如果服务由于分布式协议设计或压力的要求必须 2 个副本才能正常工作，则该做法完全不可行。 二、以较低的资源使用限速的方法从两个正常副本上拷贝数据，此方法不停服务，但可以选择服务 压力较小的时段进行。该方法的缺点是速度较慢，如果需要恢复的数据量巨大(例如数 T)，限速 较小(例如 10MB/s)，往往需要数天才能够完成恢复。
更合适的做法不是以机器作为副本单位，而是将数据拆为较合理的数据段，以数据段为单位作 为副本。实践中，常常使得每个数据段的大小尽量相等且控制在一定的大小以内。数据段有很多不 同的称谓，segment，fragment，chunk，partition 等等。数据段的选择与数据分布方式直接相关。对 于哈希分数据的方式，每个哈希分桶后的余数可以作为一个数据段，为了控制数据段的大小，常常 使得分桶个数大于集群规模。例如，有 3 台服务器，10G 数据，为了使得每个数据段都是 100M 左 右大小，哈希后按 100 取模，得 1000 个数据段，每台服务器可以负责 333 个数据段。对于按数据范 围分布数据的方式，可以将每个数据区间作为一个数据段，并控制数据区间中数据的大小。对于按 数据量分数据的方式，可以自然的按照每个数据块作为数据段。对于一致性哈希分布数据的方式， 通常的做法是讲一致性哈希环分为若干等长分区，分区个数一般远大于节点个数，假设哈希函数均 匀，则每个分区中的数据可以作为一个数据段。
一旦将数据分为数据段，则可以以数据段为单位管理副本，从而副本与机器不再硬相关，每台 机器都可以负责一定数据段的副本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.6 本地化计算&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于分布式系统而言，除了解决大规模存储问题更需要解决大规模的计算问题。然而计算离不开数 据，计算的规模往往与输入的数据量或者计算产生的中间结果的数据量正相关。在分布式系统中， 数据的分布方式也深深影响着计算的分布方式。
在分布式系统中计算节点和保存计算数据的存储节点可以在同一台物理机器上，也可以位于不 同的物理机器。如果计算节点和存储节点位于不同的物理机器则计算的数据需要通过网络传输，此 种方式的开销很大，甚至网络带宽会成为系统的总体瓶颈。另一种思路是，将计算尽量调度到与存 储节点在同一台物理机器上的计算节点上进行，这称之为本地化计算。本地化计算是计算调度的一 种重要优化，其体现了一种重要的分布式调度思想:“移动数据不如移动计算”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2基本副本协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;副本控制协议指按特定的协议流程控制副本数据的读写行为，使得副本满足一定的可用性和一 致性要求的分布式协议。副本控制协议要具有一定的对抗异常状态的容错能力，从而使得系统具有 一定的可用性，同时副本控制协议要能提供一定一致性级别。副本协议分为“中心化副本控制协议”和“去中心化的副本控制协议”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.1 中心化副本协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;中心化副本控制协议的基本思路是由一个中心节点协调副本数据的更新、维护副本之间的一致 性。中心化副本控制协议的缺点是系统的可用性依赖于中心化节点，当 中心节点异常或与中心节点通信中断时，系统将失去某些服务(通常至少失去更新服务)，所以中心 化副本控制协议的缺点正是存在一定的停服务时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.2 primary-secondary 协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本文着重介绍一种非常常用的 primary-secondary(也称 primary-backup)的中心化副本控制协议。 在 primary-secondary 类型的协议中，副本被分为两大类，其中有且仅有一个副本作为 primary 副本， 除 primary 以外的副本都作为 secondary 副本。维护 primary 副本的节点作为中心节点，中心节点负 责维护数据的更新、并发控制、协调副本的一致性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.2.1 数据更新基本流程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流程 2.2.1: Primary-secondary 协议的数据更新流程&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据更新都由 primary 节点协调完成。&lt;/li&gt;
  &lt;li&gt;外部节点将更新操作发给 primary 节点&lt;/li&gt;
  &lt;li&gt;primary 节点进行并发控制即确定并发更新操作的先后顺序&lt;/li&gt;
  &lt;li&gt;primary 节点将更新操作发送给 secondary 节点&lt;/li&gt;
  &lt;li&gt;primary 根据 secondary 节点的完成情况决定更新是否成功并将结果返回外部节点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;2.2.2.2 数据读取方式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据读取方式是 primary-secondary 类协议需要解决的第二个问题。与数据更新流程类似，读取方式也与一致性高度相关。如果只需要最终一致性，则读取任何副本都可以满足需求。如果需要会 话一致性，则可以为副本设置版本号，每次更新后递增版本号，用户读取副本时验证版本号，从而 保证用户读到的数据在会话范围内单调递增。使用 primary-secondary 比较困难的是实现强一致性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.2.3 数据同步&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Primary-secondary 型协议一般都会遇到 secondary 副本与 primary 不一致的问题。此时，不一致
的 secondary 副本需要与 primary 进行同步(reconcile)。
通常不一致的形式有三种:一、由于网络分化等异常，secondary 上的数据落后于 primary 上的 数据。二、在某些协议下，secondary 上的数据有可能是脏数据，需要被丢弃。所谓脏数据是由于 primary 副本没有进行某一更新操作，而 secondary 副本上反而进行的多余的修改操作，从而造成 secondary 副本数据错误。三、secondary 是一个新增加的副本，完全没有数据，需要从其他副本上 拷贝数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.3 去中心化副本控制协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;去中心化副本控制是另一类较为复杂的副本控制协议。与中心化副本系统协议最大的不同是，去中心化副本控制协议没有中心节点，协议中所有的节点都是完全对等的，节点之间通过平等协商 达到一致。从而去中心化协议没有因为中心化节点异常而带来的停服务等问题。图 2-9 给出了去中 心化副本控制协议的示意图。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-19-04.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;然而，没有什么事情是完美的，去中心化协议的最大的缺点是协议过程通常比较复杂。尤其当 去中心化协议需要实现强一致性时，协议流程变得复杂且不容易理解。由于流程的复杂，去中心化 协议的效率或者性能一般也较中心化协议低。一个不恰当的比方就是，中心化副本控制协议类似专 制制度，系统效率高但高度依赖于中心节点，一旦中心节点异常，系统受到的影响较大;去中心化 副本控制协议类似民主制度，节点集体协商，效率低下，但个别节点的异常不会对系统总体造成太 大影响。xd&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 Lease 机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Lease 机制是最重要的分布式协议，广泛应用于各种实际的分布式系统中。即使在某些系统中 相似的设计不被称为 lease，但我们可以分析发现其本质就是一种 lease 的实现。本节从一个分布式 cache 系统出发介绍最初的 lease 机制，接着加以引申，探讨 lease 机制的本质。最后介绍了 lease 机 制最重要的应用:判定节点状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.1 基于 lease 的分布式 cache 系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在一个分布式系统中，有一个中心服务器节点，中心服务器存储、维护 着一些数据，这些数据是系统的元数据。系统中其他的节点通过访问中心服务器节点读取、修改其 上的元数据。由于系统中各种操作都依赖于元数据，如果每次读取元数据的操作都访问中心服务器 节点，那么中心服务器节点的性能成为系统的瓶颈。为此，设计一种元数据 cache，在各个节点上 cache 元数据信息，从而减少对中心服务器节点的访问，提高性能。设计的 cache 系统要能最大可能的处理节点宕机、网络中断等 异常，最大程度的提高系统的可用性。
为此，利用 lease 机制设计一套 cache 系统，其基本原理为如下。中心服务器在向各节点发送数 据时同时向节点颁发一个 lease。每个 lease 具有一个有效期，和信用卡上的有效期类似，lease 上的 有效期通常是一个明确的时间点，例如 12:00:10，一旦真实时间超过这个时间点，则 lease 过期失效。 这样 lease 的有效期与节点收到 lease 的时间无关，节点可能收到 lease 时该 lease 就已经过期失效。 这里首先假设中心服务器与各节点的时钟是同步的，下节中讨论时钟不同步对 lease 的影响。中心服 务器发出的 lease 的含义为:在 lease 的有效期内，中心服务器保证不会修改对应数据的值。因此， 节点收到数据和 lease 后，将数据加入本地 Cache，一旦对应的 lease 超时，节点将对应的本地 cache 数据删除。中心服务器在修改数据时，首先阻塞所有新的读请求，并等待之前为该数据发出的所有 lease 超时过期，然后修改数据的值。
具体的服务器与客户端节点一个基本流程如下:
流程 
2.3.1:基于 lease 的 cache，客户端节点读取元数据&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;判断元数据是否已经处于本地 cache 且 lease 处于有效期内
1.1 是:直接返回 cache 中的元数据
1.2 否:向中心服务器节点请求读取元数据信息 
1.2.1 服务器收到读取请求后，返回元数据及一个对应的 lease
1.2.2 客户端是否成功收到服务器返回的数据
1.2.2.1 失败或超时:退出流程，读取失败，可重试
1.2.2.2 成功:将元数据与该元数据的lease记录到内存中，返回元数据
流程 2.3.2:基于 lease 的 cache，客户端节点修改元数据流程&lt;/li&gt;
  &lt;li&gt;节点向服务器发起修改元数据请求。&lt;/li&gt;
  &lt;li&gt;服务器收到修改请求后，阻塞所有新的读数据请求，即接收读请求，但不返回数据。 3. 服务器等待所有与该元数据相关的 lease 超时。&lt;/li&gt;
  &lt;li&gt;服务器修改元数据并向客户端节点返回修改成功。
上述机制可以保证各个节点上的 cache 与中心服务器上的中心始终一致。这是因为中心服务器 节点在发送数据的同时授予了节点对应的 lease，在 lease 有效期内，服务器不会修改数据，从而客 户端节点可以放心的在 lease 有效期内 cache 数据。上述 lease 机制可以容错的关键是:服务器一旦 发出数据及 lease，无论客户端是否收到，也无论后续客户端是否宕机，也无论后续网络是否正常， 服务器只要等待 lease 超时，就可以保证对应的客户端节点不会再继续 cache 数据，从而可以放心的 修改数据而不会破坏 cache 的一致性。
上述基础流程有一些性能和可用性上的问题，但可以很容易就优化改性。优化点一:服务器在 修改元数据时首先要阻塞所有新的读请求，造成没有读服务。这是为了防止发出新的 lease 从而引起 不断有新客户端节点持有 lease 并缓存着数据，形成“活锁”。优化的方法很简单，服务器在进入修 改数据流程后，一旦收到读请求则只返回数据但不颁发 lease。从而造成在修改流程执行的过程中， 客户端可以读到元数据，只是不能缓存元数据。进一步的优化是，当进入修改流程，服务器颁发的 lease 有效期限选择为已发出的 lease 的最大有效期限。这样做，客户端可以继续在服务器进入修改 流程后继续缓存元数据，但服务器的等待所有 lease 过期的时间也不会因为颁发新的 lease 而不断延 长。实际使用中，第一层优化就足够了，因为等待 lease 超时的时间会被“优化点二”中的优化方法 大大减少。优化点二:服务器在修改元数据时需要等待所有的 lease 过期超时，从而造成修改元数据 的操作时延大大增大。优化的方法是，在等待所有的 lease 过期的过程中，服务器主动通知各个持有 lease 的节点放弃 lease 并清除 cache 中的数据，如果服务器收到客户端返回的确认放弃 lease 的消息， 则服务器不需要在等待该 lease 超时。该过程中，如果因为异常造成服务器通知失败或者客户端节点 发送应答消息失败，服务器只需依照原本的流程等待 lease 超时即可，而不会影响协议的正确性。
最后，我们分析一下 cache 机制与多副本机制的区别。Cache 机制与多副本机制的相似之处都 27&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;是将一份数据保存在多个节点上。但 Cache 机制却要简单许多，对于 cache 的数据，可以随时删除 丢弃，并命中 cache 的后果仅仅是需要访问数据源读取数据;然而副本机制却不一样，副本是不能 随意丢弃的，每失去一个副本，服务质量都在下降，一旦副本数下降到一定程度，则往往服务将不 再可用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.5 日志技术&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;日志技术是宕机恢复的主要技术之一[3]。日志技术最初使用在数据库系统中。严格来说日志技 术不是一种分布式系统的技术，但在分布式系统的实践中，却广泛使用了日志技术做宕机恢复，甚 至如 BigTable 等系统将日志保存到一个分布式系统中进一步增强了系统容错能力。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/shuailaotou/booksofTN/blob/master/分布式系统原理介绍.pdf&quot;&gt;github源代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;喜欢就star一下吧！👻👻👻&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作者原创，转载请注明出处，如有错误描述，请评论纠正，谢谢大家！🐳🐳🐳&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 19 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/19/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/19/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</guid>
        
        <category>分布式系统</category>
        
        
      </item>
    
      <item>
        <title>散列算法实现Go语言Map函数</title>
        <description>&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt;一般翻译做“散列”，也有直接音译为哈希的，就是把任意长度的输入（又叫做预映射），通过散列算法，变换成固定长度的输出，该输出就是散列值，这种转化是一种压缩映射，也就是散列值的空间通常远小于输入值的空间，不同的输入可能会散列成相同的输出，二不可能从散列值来唯一的确定输入值。简单的说就是&lt;code class=&quot;highlighter-rouge&quot;&gt;一种将任意长度的消息压缩到某一固定长度的消息摘要函数。&lt;/code&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;哈希算法&quot;&gt;哈希算法&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt;主要用于信息安全领域中的加密算法，它把一些长度不同的信息转化成杂乱的128位的编码，这些编码值叫做HASH值，也可以说，hash就是找到一种数据内容和数据存放地址之间的映射关系。具体哈希算法可以参考&lt;a href=&quot;https://www.jianshu.com/p/bf1d7eee28d0&quot;&gt;哈希算法总结&lt;/a&gt;这篇文章。
&lt;br /&gt;
散列表是一种用于以常熟平均时间执行插入、删除、查找的算法。&lt;/p&gt;

&lt;h3 id=&quot;散列函数&quot;&gt;散列函数&lt;/h3&gt;
&lt;p&gt;散列表每个关键字被影射到0～ArrSize这个范围内（本文选取的数组长度为16的数组，取的关键字为&lt;code class=&quot;highlighter-rouge&quot;&gt;1103515245&lt;/code&gt;），这个映射叫做散列函数。&lt;strong&gt;上面的两个函数取值保证了，关键字被影射到0-15下标数组的概率一样。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;map实现原理&quot;&gt;Map实现原理&lt;/h3&gt;
&lt;p&gt;创建一个容量为16的链表数组，依据上面散列函数的原理，将Key值等概率的转换成0-16之间的下标值。然后根据下标值，将key和value插入到对应的下标数组中的链表上。
原理如下图：&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-16-01.png&quot; width=&quot;40%&quot; height=&quot;40%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;结构体作为数据域的类型&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
type DM struct {
	K string
	V string
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;声明全局变量，保存头结点&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var head *Node
var curr *Node

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;声明节点类型&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Node struct {
	//数据域
	Data DM
	//地址域
	NextNode *Node
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;创建头结点&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func CreateHeadNode(k string, v string) *Node {
	var node *Node = new(Node)
	//设置数据域结构体中的键值对
	node.Data.K = k
	node.Data.V = v
	//设置地址域
	node.NextNode = nil
	//保存头结点
	head = node
	curr = node

	return node

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;在指定的节点(curr)后边添加新节点&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func AddNode(k string, v string, curr *Node) *Node {
	var newNode *Node = new(Node)
	//设置新节点中的数据域
	newNode.Data.K = k
	newNode.Data.V = v

	//设置地址域
	newNode.NextNode = nil
	//挂接节点
	curr.NextNode = newNode
	curr = newNode
	//返回值
	return newNode
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;在指定的节点后边遍历链表&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func ShowNodes(n *Node) {
	var node = n
	for {
		if node.NextNode == nil {
			fmt.Print(node.Data)
			break
		} else {
			fmt.Println(node.Data)
			node = node.NextNode
		}
	}

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;计算节点的个数&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
func NodeCnt() int {
	var cnt int = 1
	var node = head
	for {
		if node.NextNode == nil {
			break
		} else {
			node = node.NextNode
			cnt = cnt + 1
		}

	}
	return cnt
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;声明全局数组&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var bultArr [16]*Node

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;给数组初始化&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func CreateBulet() {

	var arr = [16]*Node{}
	for i := 0; i &amp;lt; 16; i++ {
	 // 为数组中每个元素都创建头节点
		arr[i] = CreateHeadNode(&quot;头节点&quot;, &quot;头结点&quot;)

	}
	bultArr = arr

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;将key转换成数组下标的散列算法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;此方法为固定的方法，科学家算的🤫🤭，即上面的散列函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func HashCode(key string) int {
	var index int = 0
	index = int(key[0])
	for k := 0; k &amp;lt; len(key); k++ {
		index *= (1103515245 + int(key[k]))
	}
	index &amp;gt;&amp;gt;= 27
	index &amp;amp;= 16 - 1

	return index
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;向数组中添加键值对&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func AddKeyValue(k string, v string) {

	//计算建所对应的木桶下标
	var pos = HashCode(k)
	//获得木桶数组

	var head *Node = bultArr[pos]
	//向指定下标的头节点添加节点
	AddNode(k, v, head)

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;获取数据&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func GetValueByKey(k string) string {
	var pos = HashCode(k)
	var head *Node = bultArr[pos]
	//通过头节点遍历链表
	
	//查找对应下标下的链表，判断在key与节点中的key一直时打印
	for {
		if head.Data.K == k {
			fmt.Println(head.Data.V)
			break
		} else {
			head = head.NextNode
			if head.NextNode == nil {

			}
		}
	}

	return &quot;&quot;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;哈希散列算法的数值指定数组长度也可以是32，64，但是对应的数字就不是1103515245了，有其他的数，感兴趣的可以去查询一下。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;喜欢就star一下吧！👻👻👻&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作者原创，转载请注明出处，如有错误描述，请评论纠正，谢谢大家！🐳🐳🐳&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Wed, 16 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/16/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Go%E8%AF%AD%E8%A8%80Map%E5%87%BD%E6%95%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/16/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Go%E8%AF%AD%E8%A8%80Map%E5%87%BD%E6%95%B0/</guid>
        
        <category>散列算法，Map函数</category>
        
        
      </item>
    
      <item>
        <title>GO语言实现链表的增删改查</title>
        <description>&lt;h3 id=&quot;链表linked-list&quot;&gt;链表（Linked list）&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;链表&lt;/code&gt;是一种常见的数据结构，是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;线性表&lt;/code&gt;，但是并不会按线性的顺序存储数据，而是在每一个节点里存储到下一个节点的&lt;code class=&quot;highlighter-rouge&quot;&gt;指针&lt;/code&gt;。由于不必须的顺序存储，链表在插入的时候可以到达O（1）的&lt;code class=&quot;highlighter-rouge&quot;&gt;复杂度&lt;/code&gt;，比另一种线性表顺序快的多，但是查找一个节点或者访问特定编号的节点则需要O（n）的时间，而顺序相应的时间复杂度分别是O（logn）和O（1）。&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;链表&lt;/code&gt;通常由一连串的节点组成，每个节点包含任意的实例数据（data fields）和一或者两个用来指向上一个或者下一个的节点的位置的链接。链表最明显的好处是，常规的数字排列关联项目的方式可能不同于这些数据项目在记忆体或者磁盘上的顺序，数据的访问往往要在不同的排列书序中转换。二链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针。链表允许插入和移除表上任意位置的节点，但是不允许随机的存取。&lt;/p&gt;
&lt;h3 id=&quot;分类&quot;&gt;分类&lt;/h3&gt;
&lt;p&gt;链表有很多种类型：&lt;strong&gt;单向链表&lt;/strong&gt;，&lt;strong&gt;双向链表&lt;/strong&gt;，&lt;strong&gt;循环链表&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单向链表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它包含两个域，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;信息域&lt;/code&gt;和一个&lt;code class=&quot;highlighter-rouge&quot;&gt;指针域&lt;/code&gt;。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-15-01.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;双向链表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一种更复杂的链表是&lt;code class=&quot;highlighter-rouge&quot;&gt;“双向链表”&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;“双面链表”&lt;/code&gt;。每个节点有两个连接：一个指向前一个节点，（当此“连接”为第一个“连接”时，指向空值或者空列表）；而另一个指向下一个节点，（当此“连接”为最后一个“连接”时，指向空值或者空列表）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-15-02.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;

&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;循环链表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在一个 循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存， 假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。&lt;/p&gt;

&lt;p&gt;指向整个列表的指针可以被称作访问指针。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-15-03.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;

&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;声明全局变量，保存头节点&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //头节点
var head *Node
//当前的节点，变化的
var curr *Node

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;声明节点类型&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Node struct{
//数据域
Data  string
//地址域，指向下一个节点
NextNode  *Node
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;创建头节点&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func CreateHeadNode(data string)*Node{
//创建一个新节点
 var node *Node = new(Node)
 node.Data = data
 node.NextData = nil
 //保存头节点
 head = node
 //将curr指向头节点
 curr = node
 return node
 
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;添加新节点&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func AddNode(data string)*Node{
//创建新节点
var newNode *node = new(Node)
// 新节点赋值
newNode.Data = data
newNode.NextNode = nil
//将当前节点，也就是创建的头节点 或者要添加的上一个节点的NextNode指向新节点newNode
curr.NextNode = newNode
// 将新节点赋值给curr节点
curr = newNode
 return newNode

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;遍历链表&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func ShowNodes{
//将头节点赋值给node节点
var node = head

for {
 
 //如果头节点的地址域为空，那么这个链表只有头，直接打印
 if node.NextNode == nil{
  fmt.Print(node.Data)
  break
 }else{
 //将下一个节点赋值给node
 fmt.Println(node.Data)
 node = node.NextNode
 } 
}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;计算节点的个数&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func NodeCnt() int {
	var cnt int = 1
	var node = head
	for {
		if node.NextNode == nil {
			break
		} else {
			node = node.NextNode
			cnt = cnt + 1
		}

	}
	return cnt
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;插入节点&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func InsertNodeByIndex(index int,data string) *Node{
//在第一个位置插入
if index == 0{
 var node *Node = new(Node)
 node.Data = data
// 将新节点的地址域指向原来的头节点
 node.NextNode = head
 将新节点设为头节点
 head = node
}else if (index &amp;gt; NodeCnt()- 1){ // 在尾部插入
 AddNode(data)
}else{

var n = head
//遍历找到要插入节点的位置的节点
for (i:= 0;i&amp;lt; index -1;i++)
{
  n = n.NextNode
}

var newNode *Node = new(Node)
newNode.Data  = data
//将新节点的地址域指向下找到节点的下一个节点
newNode.NextNode = n.NextNode
//将找到节点的地址域指向新节点
n.NextNode = newNode
}
return nil

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;删除节点&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func DeleteNodeByIndex(index int){
 
 var node = head
 if index == 0{
 //删除头节点，就是第二个节点为头节点
 head = node.NextNode
 }else{
 //找到要删除的节点的前一个节点
 for(i:=0;i&amp;lt; index-1;i++){
   node = node.NextNode
 }

 node.NextNode = node.NextNode.NextNode

 } 
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Go语言中是自动垃圾回收机制，断开链接的那个节点，在程序运行结束时自动销毁&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;修改指定节点内容&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func UpdateNodeByIndex(index int,data string){

var node = head
if index == 0{
  head.Data = data
}else{
 for i := 0; i &amp;lt; index; i++ {
			node = node.NextNode
		}
		node.Data = data
}
 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;本文只是实现了简单的单向链表的基本操作，下一章将讲述一下链表的实际应用之一，Map的实现原理即行&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash散列原理&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/shuailaotou/MyHashMap&quot;&gt;github源代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;喜欢就star一下吧！👻👻👻&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作者原创，转载请注明出处，如有错误描述，请评论纠正，谢谢大家！🐳🐳🐳&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Wed, 16 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/16/GO%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/16/GO%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</guid>
        
        <category>链表</category>
        
        
      </item>
    
      <item>
        <title>使用JavaScript实现智能合约demo</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &quot;use strict&quot;
 //声明一个类，有三个属性，相当于MVC中的Model
var DictionItem = function(text){
   if(text){
     //将字符串转换成Json字符串
   var obj = Json.para(text);
    this.key = obj.key;
    this.value = obj.value;
    this.author = obj.author;
   }else{
    this.key = &quot;&quot;;
    this.value = &quot;&quot;;
    this.author = &quot;&quot;;
   }
 } ,
 //相当于MVC中的C方法，内部的方法实现将对象转化成Json字符串
DictionItem.prototype = {
  toString:function(){
    return JSON.stringify(this)
  }
}
//创建了一个类，类名字是superDiction,
 //部署一个合约会创建一个superDiction对象，通过合约地址可以找到改对象
 //合约地址可以理解成，在区块链上存储改对象的空间地址
 //每次部署合约都会产生一个新的合约对象，并且对应一个新的合约地址
 var superDiction:function(){
   //定义了一个superDiction对象的属性，属性类型为字典，对应的名字是repo
LocalContractStorage.defineMapProperty(this,&quot;repo&quot;,{
     //相当于get方法，get读取数据的时候，会讲Json字符串转换成DictionItem对象
   parse:function(text){
   return new DictionItem(text);
   }
   //相当于set方法，put或者set方法的时候，会讲对象转换成Json对象，并且写到链上
   stringify:function(o){
    return  Json.stringify(o)
   }
   });
 }, 
  superDiction.prototype ={
  init:function(){
  }
  save:function:(key,value){
    //去掉空格
  var key = key.trim();
  var value = key.trim();
  if(key == &quot;&quot;||value ==&quot;&quot;)
  {
     throw new ERROR(&quot;不能为空&quot;);
  }
  if(key.length&amp;gt;64||key.value&amp;gt;64)
   throw new ERROR(&quot;长度超标&quot;);
  }
  //自动获取当前登陆钱包的地址
  var from = Blockchain.transction.from
  //根据当前的key值，或者value
   var dicItem = this.repo.get(key);
   //如果value存在，抛出异常
   if(dicItem){
   throw new ERROR(&quot;value 已经存在&quot;);
   }
   //如果没有，则创建新的DictionItem对象存储
  var dicItem = new DictionItem();
  dicItem.key = key;
  dicItem.value = value;
  dicItem.author = from;
  this.repo.put(key,dicItem);
 },
 //查询
   get: function (key) {
        key = key.trim();
        if ( key === &quot;&quot; ) {
            throw new Error(&quot;empty key&quot;)
        }
        return this.repo.get(key);
    }
} 
 module.exports = SuperDictionary;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/shuailaotou/contract&quot;&gt;github源代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;喜欢就star一下吧！👻👻👻&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作者原创，转载请注明出处，如有错误描述，请评论纠正，谢谢大家！🐳🐳🐳&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Wed, 09 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/09/%E4%BD%BF%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6demo/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/09/%E4%BD%BF%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6demo/</guid>
        
        <category>智能合约</category>
        
        
      </item>
    
      <item>
        <title>如何创建一个React项目以及如何安装第三方的库</title>
        <description>&lt;h2 id=&quot;创建react项目&quot;&gt;创建react项目&lt;/h2&gt;

&lt;h3 id=&quot;1首先安装npm&quot;&gt;1.首先安装npm&lt;/h3&gt;
&lt;p&gt;我的Mac是使用brew安装的
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-08-01.png&quot; alt=&quot;05-08-01.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2使用npm命令创建app&quot;&gt;2.使用npm命令创建app&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.首先创建项目文件目录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-08-02.png&quot; alt=&quot;05-08-02.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.然后在上面创建的文件下执行&lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app  reactdemo&lt;/code&gt;代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-08-03.png&quot; alt=&quot;05-08-03.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注意创建的文件夹的名字不能大写&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;3使用atom打开下载好的文件-atom-&quot;&gt;3.使用atom打开下载好的文件 atom ./&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com//react05-08-04.png&quot; alt=&quot;05-08-04.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4打开之后将选中的文件删除&quot;&gt;4.打开之后将选中的文件删除&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-08-05.png&quot; alt=&quot;05-08-05.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5将indexjs中选中的代码删除&quot;&gt;5.将index.js中选中的代码删除&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-08-06.png&quot; alt=&quot;05-08-06.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6将indexjs中选中的代码改成&quot;&gt;6.将index.js中选中的代码改成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-08-07.png&quot; alt=&quot;05-08-07.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;7使用代码npm-start启动reactapp&quot;&gt;7.使用代码npm start启动reactapp&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-08-08.png&quot; alt=&quot;05-08-08.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;8运行结果&quot;&gt;8.运行结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-08-09.png&quot; alt=&quot;05-08-09.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;删除安装第三方包&quot;&gt;删除安装第三方包&lt;/h2&gt;

&lt;h3 id=&quot;1使用代码npm-uninstall-react删除react包&quot;&gt;1.使用代码npm uninstall react删除react包&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com//react05-08-10.png&quot; alt=&quot;05-08-10.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1同理使用代码npm-install-nebulas安装nebulas包&quot;&gt;1.同理使用代码npm install nebulas安装nebulas包&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/05-08-11.png&quot; alt=&quot;05-08-11.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装好之后可以在node_modules中找到nebulas的包&lt;code class=&quot;highlighter-rouge&quot;&gt;nebulas为星云链的包，星云链为区块链的公链，准备在上面开发dapp，有奖励哦👻&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;据说找工作github的Star很重要，哈哈哈。喜欢就star一下吧！👻👻👻&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作者原创，转载请注明出处，如有错误描述，请评论纠正，谢谢大家！🐳🐳🐳&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 08 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/08/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAReact%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E5%BA%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/08/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAReact%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E5%BA%93/</guid>
        
        <category>react项目</category>
        
        
      </item>
    
      <item>
        <title>go语言实现二叉搜索树</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;整理：张帅 博客 : zhangshuai.ren&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;基本概念介绍&quot;&gt;基本概念介绍&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;树(tree)  :&lt;/strong&gt;    一种分层的数据结构，类比家谱&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;二叉搜索树（binary tree）：&lt;/strong&gt; 左节点的值均小于有节点的二叉树&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;深度（depth）：&lt;/strong&gt;从 &lt;strong&gt;root&lt;/strong&gt;根结点到当前节点唯一路径的长度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;高度（height）：&lt;/strong&gt;从当前节点到一片树叶最长的路径的长度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;根（root）：&lt;/strong&gt;深度为0的树节点&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;内部节点（internal node）：&lt;/strong&gt;至少有一个字节点的节点&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;树叶节点（leaf）：&lt;/strong&gt;无字节点的节点&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;兄弟节点（sibling）&lt;/strong&gt;：拥有相同父节点的字节点波、&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/1-1.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;

&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;
&lt;p&gt;文件系统和数据库系统一般都采用树（特别是B树）的数据结构数据，主要为排序和检索的效率。二叉树是一种最基本最典型的排序树，对于学习和研究树的特性，但是本身很少在实际中进行应用。就像冒泡排序一样，二叉树因为效率问题并不实用。&lt;/p&gt;

&lt;h3 id=&quot;二叉树的常用操作&quot;&gt;二叉树的常用操作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; Insert（v） //向二叉树的合适位置插入节点&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Remove(v). // 移除树中所有值为v的节点&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Search(v)   //检查值为v的元素是否在树中&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Min().    //获取二叉树中最小的值&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Max()     //获取二叉树中最大的值&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InOrderTraverse()  //中序遍历树&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PreOrderTraverse()  //先序遍历树&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PostOrderTraverse() //后序遍历树&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String()     //在命令行格式化打印出二叉树&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同样适用genny提供代码的复用性，树类型命名为：ItemBinarySearchTree,树节点的结构体定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在命令端使用 
go get &quot;github.com/cheekybits/genny/generic&quot; 
命令获取这个包

import (
    &quot;fmt&quot;
    &quot;sync&quot;

    &quot;github.com/cheekybits/genny/generic&quot;  
)


type Item generic.Type   //generic.Type 为&quot;github.com/cheekybits/genny/generic&quot;这个包下面的一个空接口类型，type为generic.Type起别名为Item

type Node struct{
    key        int    //中序遍历的节点序号
    value      Item   //节点存储的值
    left       *Node  //左节点
    right      *Node   //右面节点
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;插入操作与遍历&quot;&gt;插入操作与遍历&lt;/h3&gt;
&lt;p&gt;插入操作需要使用到递归，插入操作需要从上到下的查找新节点在树中合适的位置，新节点的值小于任意节点，则向左子树继续寻找，同理向右子树寻找，直到树叶节点再插入。&lt;/p&gt;

&lt;p&gt;遍历操作有三种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;中序遍历(in-order)：&lt;/strong&gt;左子树（L）–&amp;gt;根节点(D)–&amp;gt;右树(R)1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;7-&amp;gt;8-&amp;gt;9-&amp;gt;10- &amp;gt;11 （LDR）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;先序遍历（pre-order）：&lt;/strong&gt;根节点(D)–&amp;gt;左子树(L)–&amp;gt;右树(R) 8-&amp;gt;4-&amp;gt;2-&amp;gt;1-&amp;gt;3-&amp;gt;6-&amp;gt;5-&amp;gt;7 &amp;gt;10-&amp;gt;9- &amp;gt;11（DLR）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;后序遍历（pre-order）：&lt;/strong&gt;左子树(L)–&amp;gt;右子树(R)–&amp;gt;根节点（D） 1-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;7-&amp;gt;6-&amp;gt;4-&amp;gt;9&amp;gt;11-&amp;gt;10- &amp;gt;8 （LRD）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;根据根节点的位置来看是什么序列遍历&lt;/em&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/1-2.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String()&lt;/code&gt; 可视化树结构&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/1-3.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/center&gt;

&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Insert&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//向二叉树合适的位置插入节点
func (tree *ItemBinarySearchTree) Insert(key int, value Item) {

//为了确保操作二叉树的数据安全，对数据操作进行读写上锁
	tree.lock.Lock()
	defer tree.lock.Unlock()
	newNode := &amp;amp;Node{key, value, nil, nil}
//如果当前的树为空，那么插入的节点作为根节点
	if tree.root == nil {
		tree.root = newNode
	} else {
	//调用下面的插入函数，另起一个方法👇
		insertNode(tree.root, newNode)
	}

}

//找到合适的位置
func insertNode(node, newNode *Node) {

//当新节点的值小于节点的值的时候，应该插入到节点的左侧
	if newNode.key &amp;lt; node.key {
	//如果旧节点左侧没有节点，那么旧节点直接赋值新节点
		if node.left == nil {
			node.left = newNode
		} else {
		//否则将左节点作为老节点，继续寻找左节点的左节点
			insertNode(node.left, newNode)
		}
	} else {
	//与上面同理
		if node.right == nil {
			node.right = newNode
		} else {
			insertNode(node.right, newNode)
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Search&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//检查key的元素是否存在
func (tree *ItemBinarySearchTree) Search(key int) bool {

	tree.lock.Lock()
	defer tree.lock.Unlock()
	return search(tree.root, key)

}
func search(node *Node, key int) bool {

	if node == nil {
		return false
	}
  //如果key的值小于节点的值，那么应该插入到左子树
	if key &amp;lt; node.key {
	//将左子树作为新节点，继续查询
		return search(node.left, key)
	}
	
	// 如果key的值大于节点的值，那么应该插入右子树
	if key &amp;gt; node.key {
	//将右子树作为新节点，继续查询
		return search(node.right, key)
	}

//如果当前key的值==node.key 返回true
	return true

}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Remove&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;删除节点的流程&quot;&gt;删除节点的流程&lt;/h5&gt;

&lt;p&gt;先递归查找，再删除节点。但是在删除时需要根据节点拥有子节点的数量，分如下3中情况：
&lt;img src=&quot;http://p7rz9r9fd.bkt.clouddn.com/1-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码实现-1&quot;&gt;代码实现&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
func (tree *ItemBinarySearchTree) remove(key int) {

	tree.lock.Lock()
	defer tree.lock.Unlock()
	remove(tree.root, key)
	
}

func remove(node *Node, key int) *Node {
	if node == nil {
		return nil
	}
	
   // 如果key&amp;lt; node.key 则向左寻找
	
	if key &amp;lt; node.key {
	
		// 将左节点作为新节点递归继续寻找
		
		node.left = remove(node.left, key)
		return node
	}

	// 如果key&amp;gt; node.key 则向右寻找

	if key &amp;gt; node.key {
	
	// 将右节点作为新节点递归继续寻找
	
		node.right = remove(node.right, key)
		return node
	}

//如果key==node.key 判断node有没有左右子树，如果没有，则直接删除
	if node.left == nil &amp;amp;&amp;amp; node.right == nil {

		node = nil
		return node
	}
//如果key==node.key 判断node有没有左右子树，如果有右子树，则将右子树直接赋值给当前节点，完成覆盖删除
	if node.left == nil {
		node = node.right
		return node
	}
	
	//如果key==node.key 判断node有没有左右子树，如果有右子树，则将右子树直接赋值给当前节点，完成覆盖删除
	
	if node.right == nil {
		node = node.left
		return node
	}

	mostLeftMode := node.right
// 要删除的节点有2个字节点，找到右子树的最左节点，替换当前节点􏱚􏱐􏲝􏰈􏰖􏰗􏰛 
	for {
	
	//一直遍历找到最左节点
		if mostLeftMode != nil &amp;amp;&amp;amp; mostLeftMode.left != nil {
			mostLeftMode = mostLeftMode.left
		} else {
			break
		}

	}

// 使用右子树的最左节点替换当前的节点，即删除当前节点
	node.key, node.value = mostLeftMode.key,mostLeftMode.value

	node.right = remove(node.right, node.key)

	return node

}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Max&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取最大节点即为二叉树最右节点，根据二叉树的性质

func (tree *ItemBinarySearchTree) Max() *Item {

	tree.lock.Lock()
	defer tree.lock.Unlock()
	node := tree.root
	if node == nil {
		return nil
	}
	for {

		if node.right == nil {
			return &amp;amp;node.value
		}

		node = node.right
	}

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Min&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-'&quot;&gt;
// 根据二叉树的性质,获取最大节点即为二叉树最右节点

func (tree *ItemBinarySearchTree) Min() *Item {

	tree.lock.Lock()
	defer tree.lock.Unlock()

	node := tree.root

	if node == nil {
		return nil
	}

	for {
		if node.left == nil {
			return &amp;amp;node.value
		} else {
			node = node.left
		}

	}

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Traverse&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// 先序遍历：根节点 -&amp;gt; 左子树 -&amp;gt;右子树
func (tree *ItemBinarySearchTree) PreOrderTraverse(printFunc func(Item)) {

	tree.lock.Lock()
	defer tree.lock.Unlock()
	
	preOrderTraverse(tree.root, printFunc)

}

func preOrderTraverse(node *Node, printFunc func(Item)) {

	if node != nil {
	//先打印根节点
		printFunc(node.value)
		
		//然后递归调用自己，将左节点作为新节点，打印
		preOrderTraverse(node.left, printFunc)
		//然后递归调用自己，将右节点作为新节点，打印
		preOrderTraverse(node.right, printFunc)

	}

}

// 中序遍历： 左子树 -&amp;gt;根节点 -&amp;gt;右子树
func (tree *ItemBinarySearchTree) PostOrderTraverse(printFunc func(Item)) {

	tree.lock.Lock()
	defer tree.lock.Unlock()

	postOrderTraverse(tree.root, printFunc)

}

func postOrderTraverse(node *Node, printFunc func(Item)) {

	if node != nil {
    //递归调用自己，将左节点作为新节点，打印
		preOrderTraverse(node.left, printFunc)
		//打印根节点
		printFunc(node.value)
		//递归调用自己，将右节点作为新节点，打印
		preOrderTraverse(node.right, printFunc)

	}

}


// 后序遍历： 左子树  -&amp;gt;右子树-&amp;gt;根节点

func (tree *ItemBinarySearchTree) InOrderTraverse(printFunc func(Item)) {

	tree.lock.Lock()
	defer tree.lock.Unlock()

	inOrderTraverse(tree.root, printFunc)

}

func inOrderTraverse(node *Node, printFunc func(Item)) {

	if node != nil {
     //递归调用自己，将左节点作为新节点，打印
		preOrderTraverse(node.left, printFunc)
		//递归调用自己，将右节点作为新节点，打印
		preOrderTraverse(node.right, printFunc)
		//打印根节点
		printFunc(node.value)

	}

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
//后序遍历打印树的结构
func (tree *ItemBinarySearchTree) String() {
	tree.lock.Lock()
	defer tree.lock.Unlock()
	if tree.root == nil {
		println(&quot;Tree is empty&quot;)
		return
	}
	stringify(tree.root, 0)
	println(&quot;----------------------------&quot;)
}
func stringify(node *Node, level int) {
	if node == nil {
		return
	}
	format := &quot;&quot;
	for i := 0; i &amp;lt; level; i++ {
		format += &quot;\t&quot; //根据节点的深度决定缩进长度

	}
	format += &quot;----[ &quot;
	level++
	//先递归打印左子树􏱈􏱉􏱊􏱋􏱌􏰟􏰜􏰀 
	stringify(node.left, level)
	//打印值
	fmt.Printf(format+&quot;%d\n&quot;, node.key) 
	//再递归打印右子树
	 stringify(node.right, level)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;对于二叉树的操作，增删查都与递归相关，所以实现的时候一定要分析清楚递归的终止条件，在正确的条件下return，避开死循环。&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 03 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/03/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/03/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
        
        <category>二叉树</category>
        
        
      </item>
    
  </channel>
</rss>
